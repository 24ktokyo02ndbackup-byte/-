local updatelog = {[[

]]}


spawn(function()
function IsMobile()
    if getgenv().IsMobile then 
        return true
    else 
        return false
    end
end

function GetSize()
    if IsMobile() then 
        return UDim2.fromOffset(550, 450)
    else 
        return UDim2.fromOffset(550, 650)
     end
 end

getgenv().Zero = {
    ['Ragebot'] = {
        ['Enabled'] = (false),
        ['Hitpart'] = ("Head"),
        ['Keybind'] = (Enum.KeyCode.Q),
        ['Autofire'] = (false),
        ['RandomHitPart'] = (false),
        ['Autokill'] = (false),
        ['BulletTP'] = (false),
        ['Multigun'] = (false),

		['FollowTarget'] = {
			['Enabled'] = (false),
			['Mode'] = ("Random"), -- "Random" or "Strafe"
			['Radius'] = (10),
            ['Spectate'] = (false)
		},
        ['Checks'] = {
            ['Ko'] = (true),
			['Health_limit'] = (1.5), -- 1.5 for most games, if sometimes doesnt unlock then set as 2 or 2.5
            ['Wall'] = (true)
        },
        ['Others'] = {
            ['NotificationsEnabled'] = (false),
            ['Tracer'] = {
                ['Enabled'] = (true),
                ['Color'] = (Color3.fromRGB(255, 255, 255))
            },
            ['HitSound'] = (true),
            ['Sound'] = ("neverlose") -- options: neverlose, coin, pop, error, click, snipe, uwu, retro, sf
        },
		['ConnectionExploit'] = (false),
        ['Kill_Aura'] = {
            ['Enabled'] = (false),
            ['Mode'] = ("Normal"), -- Normal or Aug
            ['Radius'] = (15)
        }
    },

    ['Silent'] = {
        ['Enabled'] = (false),
        ['MagicBullet'] = (false),
        ['Hitpart'] = ("Head"),
        ['Airhitpart'] = ("HumanoidRootPart"),
        ['Closesthitpart'] = (false),
        ['Checks'] = {
            ['Ko'] = (true),
            ['Health_limit'] = (1.5), -- 1.5 for most games, if sometimes doesnt unlock then set as 2 or 2.5
            ['Wall'] = (true)
        },
        ['FOV'] = {
            ['Enabled'] = (true),
            ['Radius'] = 150 ,
			['ShowFOV'] = (false)
        },
		['HitSound'] = (true),
        ['Sound'] = ("neverlose") -- options: neverlose, coin, pop, error, click, snipe, uwu, retro, sf
    },

	['Resolver'] = {
        ['Enabled'] = (false),
        ['Method'] = ("MoveDirection"), -- "Velocity", "MoveDirection", "Recalculate"
        ['Confidence'] = (0.133), 
        ['Sensitivity'] = (1000), 
        ['AutoPing'] = (true), 
        ['MaxPing'] = (200),
    },

    ['Self'] = {
        ['CFrameSpeed'] = {
            ['Enabled'] = (false),
            ['Keybind'] = (Enum.KeyCode.B),
            ['Speed'] = (5) 
        },

        ['CFrameFly'] = {
            ['Enabled'] = (true),
            ['Keybind'] = (Enum.KeyCode.Z),
            ['Speed'] = (5)
        },

        ['Voidhide'] = {
            ['Enabled'] = (false),
            ['Keybind'] = (Enum.KeyCode.V),
            ['VoidMode'] = ("Normal"), -- "Normal" or "Spam"
			['Visualize_Desync'] = (true)
        }
    },

	['Otherslol'] = {
		['Armorkeybind'] = (Enum.KeyCode.X),
        ['Autostomp'] = (true),
        ['Autoreload'] = (true),
        ['Rapidfire'] = (true),
        ['Antiflame'] = (false),
	},

	['Chams'] = {
        ['Enabled'] = (false),
        ['TeamCheck'] = (false),
        ['FillColor'] = (Color3.fromRGB(0, 0, 0)),
        ['FillTransparency'] = (0.8),
        ['OutlineColor'] = (Color3.fromRGB(224,33,138)),
        ['OutlineTransparency'] = (0)
    },

    ['BoxESP'] = {
        ['Enabled'] = (false),
        ['Type'] = ("Full"), -- Full , Corner
        ['Color'] = (Color3.fromRGB(255, 255, 255)),
    }
}

loadstring(game:HttpGet("https://pastebin.com/raw/WmwZK16V"))() -- adonis bypass

local HoodcustomsId = {
    [9825515356] = true,
    [138995385694035] = true
}

local DahoodId = {
    [2788229376] = true
}

-- Loaders:
local desync = loadstring(game:HttpGet("https://pastebin.com/raw/9WENs29j"))()
local AnimationLoader = loadstring(game:HttpGet("https://raw.githubusercontent.com/24ktokyo02ndbackup-byte/scripts/refs/heads/main/animation%20by%20ai%20lol"))()
local desyncwasenabled
task.spawn(function()
    while task.wait(0.01) do 
        if getgenv().Zero.Otherslol.Autostomp then
            game:GetService("ReplicatedStorage").MainEvent:FireServer("Stomp")
        end
    end
end)

-- Auto Reload
game:GetService("RunService").Heartbeat:Connect(function()
pcall(function()
    if not getgenv().Zero.Otherslol.Autoreload then return end
local hastool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")

if HoodcustomsId[game.PlaceId] then 
if hastool.Script.Ammo.Value == 0 then 
            game:GetService("VirtualInputManager"):SendKeyEvent(true, "R", false, game)
    task.wait(0.1)
    game:GetService("VirtualInputManager"):SendKeyEvent(false, "R", false, game)
end
else 
   
if hastool.Ammo.Value == 0 then 
            game:GetService("VirtualInputManager"):SendKeyEvent(true, "R", false, game)
    task.wait(0.1)
    game:GetService("VirtualInputManager"):SendKeyEvent(false, "R", false, game)
end
end
end)
end)


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer


local patched = setmetatable({}, { __mode = "k" })

local function applyRapidFire(tool)
    pcall(function()
        if patched[tool] then return end
    if not tool:FindFirstChild("GunScript") then return end

    patched[tool] = true

    for _, conn in ipairs(getconnections(tool.Activated)) do
        local fn = conn.Function
        local info = debug.getinfo(fn)
        if not info or not info.nups then continue end

        for i = 1, info.nups do
            local up = debug.getupvalue(fn, i)
            if type(up) == "number" and up > 0.01 and up < 1 then
                debug.setupvalue(fn, i, 1e-20)
            end
        end
    end
end)
end

game:GetService("RunService").Heartbeat:Connect(function()
if not getgenv().Zero.Otherslol.Rapidfire then return end
local niggatool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
applyRapidFire(niggatool)
end)



local Players = game:GetService("Players")
local Cam = workspace.CurrentCamera
local Client = Players.LocalPlayer
local Mouse = Client:GetMouse()
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Vector2New = Vector2.new
local RagebotReady = false


local LocalPlayer = Players.LocalPlayer


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Cam = workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Cam = workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer

-- CFrame Fly
local flyActive = false

UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == getgenv().Zero.Self.CFrameFly.Keybind and getgenv().Zero.Self.CFrameFly.Enabled then
        flyActive = not flyActive
    end
end)


RunService.Heartbeat:Connect(function(dt)
    if not flyActive or not getgenv().Zero.Self.CFrameFly.Enabled then return end
    
    local character = Client.Character
    if not character then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local hum = character:FindFirstChild("Humanoid")
    if not hrp or not hum then return end
    
    local camera = workspace.CurrentCamera
    
   
    local cameraCFrame = camera.CFrame
    local lookVector = cameraCFrame.LookVector  
    local rightVector = cameraCFrame.RightVector  
    
  
    local moveDirection = Vector3.new(0, 0, 0)

    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
        moveDirection = moveDirection + lookVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
        moveDirection = moveDirection - lookVector
    end
    

    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
        moveDirection = moveDirection - rightVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
        moveDirection = moveDirection + rightVector
    end
    

    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
        moveDirection = moveDirection + Vector3.new(0, 1, 0)
    end

    if moveDirection.Magnitude > 0 then
        moveDirection = moveDirection.Unit
        hrp.CFrame = hrp.CFrame + (moveDirection * dt) * getgenv().Zero.Self.CFrameFly.Speed * 100
    end
    

    hrp.Velocity = (hrp.Velocity * Vector3.new(1, 0, 1)) + Vector3.new(0, 1.9, 0)
end)



local ESPs = {}
local ESPEnabled = {
    Name = false,
    Distance = false,
    Weapon = false
}


local function newText(size)
    local t = Drawing.new("Text")
    t.Center = true
    t.Outline = true
    t.OutlineColor = Color3.new(0, 0, 0)
    t.Color = Color3.new(1, 1, 1)
    t.Size = size
    t.Visible = false
    return t
end


local function createESP(player)
    if player == LocalPlayer or ESPs[player] then return end

    ESPs[player] = {
        Name = newText(22),
        Distance = newText(18),
        Weapon = newText(18)
    }

    player.AncestryChanged:Connect(function()
        if not player:IsDescendantOf(game) then
            for _, d in pairs(ESPs[player]) do
                d:Remove()
            end
            ESPs[player] = nil
        end
    end)
end

for _, p in ipairs(Players:GetPlayers()) do
    createESP(p)
end
Players.PlayerAdded:Connect(createESP)


RunService.RenderStepped:Connect(function()
    for player, esp in pairs(ESPs) do
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local lhrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

        if not hrp then
            for _, d in pairs(esp) do d.Visible = false end
            continue
        end

    
        local basePos, onScreen = Cam:WorldToViewportPoint(hrp.Position - Vector3.new(0, hrp.Size.Y/2 + 1, 0))
        if not onScreen then
            for _, d in pairs(esp) do d.Visible = false end
            continue
        end

        local yOffset = 0

      
        if ESPEnabled.Name then
            esp.Name.Text = player.DisplayName
            esp.Name.Position = Vector2.new(basePos.X, basePos.Y + yOffset)
            esp.Name.Visible = true
            yOffset += 18
        else
            esp.Name.Visible = false
        end

        
        if ESPEnabled.Distance and lhrp then
            local dist = math.floor((lhrp.Position - hrp.Position).Magnitude)
            esp.Distance.Text = dist .. " studs"
            esp.Distance.Position = Vector2.new(basePos.X, basePos.Y + yOffset)
            esp.Distance.Visible = true
            yOffset += 16
        else
            esp.Distance.Visible = false
        end

      
        if ESPEnabled.Weapon then
            local tool = char:FindFirstChildOfClass("Tool")
            esp.Weapon.Text = tool and tool.Name or "None"
            esp.Weapon.Position = Vector2.new(basePos.X, basePos.Y + yOffset)
            esp.Weapon.Visible = true
        else
            esp.Weapon.Visible = false
        end
    end
end)


function toggleESP(type, state)
    if ESPEnabled[type] ~= nil then
        ESPEnabled[type] = state
    end
end



local ChamsData = {}

local function createChams(player)
    if player == LocalPlayer then return end
    if ChamsData[player] then return end

    local data = {
        player = player,
        highlight = nil,
        connection = nil
    }

    local function setup()
        if not player.Character then return end

       
        if data.highlight then
            data.highlight:Destroy()
            data.highlight = nil
        end

       
        local highlight = Instance.new("Highlight")
        highlight.Name = "Cham"
        highlight.Adornee = player.Character
        highlight.FillColor = getgenv().Zero.Chams.FillColor
        highlight.FillTransparency = getgenv().Zero.Chams.FillTransparency
        highlight.OutlineColor = getgenv().Zero.Chams.OutlineColor
        highlight.OutlineTransparency = getgenv().Zero.Chams.OutlineTransparency
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop

        highlight.Parent = player.Character

        data.highlight = highlight
    end

    data.connection = player.CharacterAdded:Connect(setup)
    
   
    setup()

    ChamsData[player] = data
end

local function removeChams(player)
    local data = ChamsData[player]
    if not data then return end

    if data.highlight then
        data.highlight:Destroy()
    end

    if data.connection then
        data.connection:Disconnect()
    end

    ChamsData[player] = nil
end

local function updateChams()
    for player, data in pairs(ChamsData) do
        if data.highlight then
            data.highlight.Enabled = getgenv().Zero.Chams.Enabled
            data.highlight.FillColor = getgenv().Zero.Chams.FillColor
            data.highlight.FillTransparency = getgenv().Zero.Chams.FillTransparency
            data.highlight.OutlineColor = getgenv().Zero.Chams.OutlineColor
            data.highlight.OutlineTransparency = getgenv().Zero.Chams.OutlineTransparency
        end
    end
end

for _, player in pairs(Players:GetPlayers()) do
    createChams(player)
end


Players.PlayerAdded:Connect(createChams)
Players.PlayerRemoving:Connect(removeChams)


RunService.RenderStepped:Connect(function()
    updateChams()
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local BoxESP = getgenv().Zero.BoxESP

local cache = {}

local function newSquare()
    local s = Drawing.new("Square")
    s.Thickness = 1
    s.Filled = false
    s.Visible = false
    return s
end

local function newLine()
    local l = Drawing.new("Line")
    l.Thickness = 0.0001
    l.Visible = false
    return l
end

local function createESP(player)
    cache[player] = {
        Full = {
            Square = newSquare(),
            Outline = newSquare(),
            Inline = newSquare()
        },
        Corner = {
            TL1 = newLine(), TL2 = newLine(),
            TR1 = newLine(), TR2 = newLine(),
            BL1 = newLine(), BL2 = newLine(),
            BR1 = newLine(), BR2 = newLine()
        }
    }
end

local function removeESP(player)
    if not cache[player] then return end
    for _, v in pairs(cache[player].Full) do v:Remove() end
    for _, v in pairs(cache[player].Corner) do v:Remove() end
    cache[player] = nil
end

local function hideAll(player)
    if not cache[player] then return end
    for _, v in pairs(cache[player].Full) do v.Visible = false end
    for _, v in pairs(cache[player].Corner) do v.Visible = false end
end

local function updateESP(player)
    if not BoxESP.Enabled then
        hideAll(player)
        return
    end

    local char = player.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then
        hideAll(player)
        return
    end

    local sizeY = char:GetExtentsSize().Y / 2
    local top = Camera:WorldToViewportPoint(root.Position + Vector3.new(0, sizeY, 0))
    local bottom = Camera:WorldToViewportPoint(root.Position - Vector3.new(0, sizeY, 0))

    if top.Z <= 0 or bottom.Z <= 0 then
        hideAll(player)
        return
    end

    local height = bottom.Y - top.Y
    local width = height * 0.65
    local pos = Vector2.new(top.X - width / 2, top.Y)
    local size = Vector2.new(width, height)

    hideAll(player)

    if BoxESP.Type == "Full" then
        local f = cache[player].Full

        f.Square.Visible = true
        f.Square.Position = pos
        f.Square.Size = size
        f.Square.Color = BoxESP.Color

        f.Outline.Visible = true
        f.Outline.Position = pos - Vector2.new(1,1)
        f.Outline.Size = size + Vector2.new(2,2)
        f.Outline.Color = Color3.new(0,0,0)

        f.Inline.Visible = true
        f.Inline.Position = pos + Vector2.new(1,1)
        f.Inline.Size = size - Vector2.new(2,2)
        f.Inline.Color = Color3.new(0,0,0)

    elseif BoxESP.Type == "Corner" then
        local c = cache[player].Corner
        local l = width * 0.25

        local tl = pos
        local tr = pos + Vector2.new(width, 0)
        local bl = pos + Vector2.new(0, height)
        local br = pos + Vector2.new(width, height)

        -- top left
        c.TL1.From, c.TL1.To = tl, tl + Vector2.new(l, 0)
        c.TL2.From, c.TL2.To = tl, tl + Vector2.new(0, l)

        -- top right
        c.TR1.From, c.TR1.To = tr, tr - Vector2.new(l, 0)
        c.TR2.From, c.TR2.To = tr, tr + Vector2.new(0, l)

        -- bottom left
        c.BL1.From, c.BL1.To = bl, bl + Vector2.new(l, 0)
        c.BL2.From, c.BL2.To = bl, bl - Vector2.new(0, l)

        -- bottom right
        c.BR1.From, c.BR1.To = br, br - Vector2.new(l, 0)
        c.BR2.From, c.BR2.To = br, br - Vector2.new(0, l)

        for _, line in pairs(c) do
            line.Color = BoxESP.Color
            line.Visible = true
        end
    end
end

-- init
for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LocalPlayer then
        createESP(p)
    end
end

Players.PlayerAdded:Connect(function(p)
    if p ~= LocalPlayer then
        createESP(p)
    end
end)

Players.PlayerRemoving:Connect(removeESP)

RunService.RenderStepped:Connect(function()
    for player in pairs(cache) do
        updateESP(player)
    end
end)




local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Color = Color3.fromRGB(255, 255, 255)
FOVCircle.Thickness = 1
FOVCircle.NumSides = 64
FOVCircle.Radius = getgenv().Zero.Silent.FOV.Radius or 150
FOVCircle.Filled = false

RunService.RenderStepped:Connect(function()
    if not getgenv().Zero.Silent.FOV.ShowFOV then
        FOVCircle.Visible = false
        return
    end

    if getgenv().Zero.Silent.FOV.Enabled then
        if IsMobile() then
            local vp = workspace.CurrentCamera.ViewportSize
            FOVCircle.Position = Vector2.new(vp.X / 2, vp.Y / 2)
        else
            FOVCircle.Position = UserInputService:GetMouseLocation()
        end

        FOVCircle.Radius = getgenv().Zero.Silent.FOV.Radius or 150
        FOVCircle.Visible = true
    else
        FOVCircle.Visible = false
    end
end)








local CurrentTarget = nil
local LockedOn = false



local ResolverCache = {}
local PingHistory = {}
local MaxPingHistorySize = 10


local function GetAveragePing()
    if #PingHistory == 0 then return 0 end
    local sum = 0
    for _, ping in ipairs(PingHistory) do
        sum = sum + ping
    end
    return sum / #PingHistory
end


RunService.Heartbeat:Connect(function()
    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
    table.insert(PingHistory, ping)
    if #PingHistory > MaxPingHistorySize then
        table.remove(PingHistory, 1)
    end
end)


local function ResolvePosition(character)
    if not getgenv().Zero.Resolver.Enabled then
        return nil
    end
    
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local hum = character:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum then return nil end
    
   
    local pos = hrp.Position
    local vel = hrp.Velocity or hrp.AssemblyLinearVelocity or Vector3.new(0,0,0)  -- ✅ FIXED
    
    
    if vel.Magnitude < 0.1 then
        return pos 
    end
    
    
    local pingDiv = 0
    if getgenv().Zero.Resolver.AutoPing then
        local avgPing = GetAveragePing()
        if avgPing > getgenv().Zero.Resolver.MaxPing then
            return pos 
        end
        pingDiv = avgPing / 1000 
    else
        pingDiv = 0.1 
    end
    

    local absY = math.abs(vel.Y)
    if absY > 100 then
        vel = Vector3.new(vel.X, vel.Y * 0.3, vel.Z)
    end
    
   
    local speed = math.sqrt(vel.X * vel.X + vel.Z * vel.Z)
    speed = math.min(speed, 150) 
    
    local confidence = getgenv().Zero.Resolver.Confidence
    local sensitivity = getgenv().Zero.Resolver.Sensitivity
    local pred = confidence + speed/sensitivity + pingDiv
    
  
    if getgenv().Zero.Resolver.Method == "MoveDirection" and hum then
        
        local moveDir = hum.MoveDirection
        if moveDir.Magnitude > 0 then
            local moveSpeed = hum.WalkSpeed or 16
            vel = Vector3.new(
                moveDir.X * moveSpeed,
                vel.Y,
                moveDir.Z * moveSpeed
            )
        end
    elseif getgenv().Zero.Resolver.Method == "Recalculate" then
       
        local cache = ResolverCache[character]
        if cache then
           
            vel = (vel + cache.lastVel) * 0.5
            cache.lastVel = hrp.Velocity or hrp.AssemblyLinearVelocity or Vector3.new(0,0,0)  -- ✅ FIXED
        else
            ResolverCache[character] = {
                lastVel = hrp.Velocity or hrp.AssemblyLinearVelocity or Vector3.new(0,0,0),  -- ✅ FIXED
                lastPos = pos
            }
        end
    end
    
    
    local projected = Vector3.new(
        pos.X + vel.X * pred,
        pos.Y + vel.Y * pred,
        pos.Z + vel.Z * pred
    )
    
    return projected
end


Players.PlayerRemoving:Connect(function(player)
    if player.Character then
        ResolverCache[player.Character] = nil
    end
end)


local function WallCheck(destination, ignore)
    local success, result = pcall(function()
        local origin = Cam.CFrame.Position
        local ray = Ray.new(origin, destination - origin)
        local hit = workspace:FindPartOnRayWithIgnoreList(ray, ignore)
        return hit == nil
    end)
    
    if success then
        return result
    else
        
        return true
    end
end



local function IsKO(character, healthLimit)
    local hum = character:FindFirstChildOfClass("Humanoid")
    if not hum then return true end


    local bodyEffects = character:FindFirstChild("BodyEffects")
    if bodyEffects then
        local ko = bodyEffects:FindFirstChild("K.O")
            or bodyEffects:FindFirstChild("KO")
            or bodyEffects:FindFirstChild("Downed")
        if ko and ko.Value == true then
            return true
        end
    end

   
    if hum.Health <= (healthLimit or 1.5) then
        return true
    end

    return false
end

local function GetClosestPartToMouse(character)
    local referencePos
    
    if IsMobile() then
        local vp = workspace.CurrentCamera.ViewportSize
        referencePos = Vector2.new(vp.X / 2, vp.Y / 2)
    else
      
        referencePos = UserInputService:GetMouseLocation()
    end
    
    local closestPart, closestDist = nil, math.huge

    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            local screenPos, onScreen = Cam:WorldToViewportPoint(part.Position)
            if onScreen and screenPos.Z > 0 then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - referencePos).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closestPart = part
                end
            end
        end
    end

    return closestPart, closestDist
end


local _silentHitConnection = nil
local _currentSilentTarget = nil

local function setupSilentHitSound(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return end
    local hum = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not hum then return end

   
    if _currentSilentTarget == targetPlayer then return end
    
    
    if _silentHitConnection then
        _silentHitConnection:Disconnect()
        _silentHitConnection = nil
    end

    _currentSilentTarget = targetPlayer
    local lastHealth = hum.Health

    _silentHitConnection = hum.HealthChanged:Connect(function(newHealth)
        if newHealth < lastHealth then
            local root = targetPlayer.Character:FindFirstChild("HumanoidRootPart")

            if getgenv().Zero.Silent.HitSound and root then
                local soundTable = {
                    neverlose = 6534948092,
                    coin = 3125624765,
                    pop = 6586979979,
                    error = 550209561,
                    click = 87437544236708,
                    snipe = 137392628136734,
                    uwu = 8323804973,
                    retro = 118157652132357,
                    sf = 91656203252586
                }
                local soundId = soundTable[getgenv().Zero.Silent.Sound] or 6534948092
                pcall(function()
                    local sound = Instance.new("Sound")
                    sound.SoundId = "rbxassetid://"..soundId
                    sound.Volume = 555555555555
                    sound.PlayOnRemove = true
                    sound.Parent = root
                    sound:Destroy()
                end)
            end
        end
        lastHealth = newHealth
    end)
end

local SilentFiring = false

local function GetClosestToMouseMagic()
   
    if not Client then 
        return nil 
    end
    
    local myChar = Client.Character
    if not myChar then 
        return nil 
    end
    
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then
        return nil
    end
    
    local referencePos
    if IsMobile() then
        local vp = workspace.CurrentCamera.ViewportSize
        referencePos = Vector2.new(vp.X / 2, vp.Y / 2)
    else
        referencePos = UserInputService:GetMouseLocation()
    end

    local closestPlayer = nil
    local closestDist = math.huge

    for _, player in ipairs(Players:GetPlayers()) do
       
        if player == Client then continue end

       
        local char
        local valid = pcall(function()
            char = player.Character
            if not char then return false end
            
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hrp or not hum or hum.Health <= 0 then return false end
            
            return true
        end)
        
        if not valid or not char then continue end

        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hrp or not hum then continue end

        
        if getgenv().Zero.Silent.Checks.Ko then
            local isKOed = false
            pcall(function()
                isKOed = IsKO(char, getgenv().Zero.Silent.Checks.Health_limit)
            end)
            if isKOed then
                continue
            end
        end

       
        local targetPos = hrp.Position
        if getgenv().Zero.Resolver.Enabled then
            pcall(function()
                local resolved = ResolvePosition(char)
                if resolved and typeof(resolved) == "Vector3" then
                    targetPos = resolved
                end
            end)
        end

        
        if getgenv().Zero.Silent.Checks.Wall then
            local ignoreList = {char}
            if myChar then
                table.insert(ignoreList, myChar)
            end
            
            local wallCheckOk = false
            pcall(function()
                wallCheckOk = WallCheck(targetPos, ignoreList)
            end)
            
            if not wallCheckOk then
                continue
            end
        end

        
        local screenPos, onScreen
        local screenCheckOk = pcall(function()
            screenPos, onScreen = Cam:WorldToViewportPoint(targetPos)
        end)
        
        if not screenCheckOk or not onScreen or not screenPos or screenPos.Z <= 0 then 
            continue 
        end

        
        local dist = (Vector2.new(screenPos.X, screenPos.Y) - referencePos).Magnitude

        
        if getgenv().Zero.Silent.FOV.Enabled then
            if dist > getgenv().Zero.Silent.FOV.Radius then
                continue
            end
        end

        
        if dist < closestDist then
            closestDist = dist
            closestPlayer = player
        end
    end

    return closestPlayer
end


local function GetMagicBulletHitpart(target)
    if not target or not target.Character then 
        return nil 
    end
    
    local char = target.Character
    if not char then return nil end
    
    
    if getgenv().Zero.Silent.Closesthitpart then
        local part = GetClosestPartToMouse(char)
        if part then
            return part
        end
    end
    
  
    local hum = char:FindFirstChildOfClass("Humanoid")
    local hitpartName = getgenv().Zero.Silent.Hitpart
    
    if hum and hum.FloorMaterial == Enum.Material.Air then
        hitpartName = getgenv().Zero.Silent.Airhitpart
    end
    
    return char:FindFirstChild(hitpartName)
end


local CurrentMagicTarget = nil
local MagicHealthConnection = nil
local MagicLastHealth = nil

local function setupMagicTargetMonitor(target)
    -- If it's the same target and connection exists, don't recreate
    if CurrentMagicTarget == target and MagicHealthConnection then 
        return 
    end
    
    -- Clean up old connection
    if MagicHealthConnection then
        MagicHealthConnection:Disconnect()
        MagicHealthConnection = nil
    end
    
    -- Reset if no target
    if not target or not target.Character then
        CurrentMagicTarget = nil
        MagicLastHealth = nil
        return
    end
    
    local hum = target.Character:FindFirstChildOfClass("Humanoid")
    if not hum then
        CurrentMagicTarget = nil
        MagicLastHealth = nil
        return
    end
    
    CurrentMagicTarget = target
    MagicLastHealth = hum.Health
    
    -- Set up health monitor for this target only
    MagicHealthConnection = hum.HealthChanged:Connect(function(newHealth)
        if newHealth < MagicLastHealth then
            local root = target.Character:FindFirstChild("HumanoidRootPart")
            
            if getgenv().Zero.Silent.HitSound and root then
                local soundTable = {
                    neverlose = 6534948092,
                    coin = 3125624765,
                    pop = 6586979979,
                    error = 550209561,
                    click = 87437544236708,
                    snipe = 137392628136734,
                    uwu = 8323804973,
                    retro = 118157652132357,
                    sf = 91656203252586
                }
                local soundId = soundTable[getgenv().Zero.Silent.Sound] or 6534948092
                pcall(function()
                    local sound = Instance.new("Sound")
                    sound.SoundId = "rbxassetid://"..soundId
                    sound.Volume = 555555555555
                    sound.PlayOnRemove = true
                    sound.Parent = root
                    sound:Destroy()
                end)
            end
        end
        MagicLastHealth = newHealth
    end)
end

-- Clean up on target death/respawn
local function cleanupMagicMonitor()
    if MagicHealthConnection then
        MagicHealthConnection:Disconnect()
        MagicHealthConnection = nil
    end
    CurrentMagicTarget = nil
    MagicLastHealth = nil
end

-- Watch for target respawn/death
Players.PlayerRemoving:Connect(function(player)
    if player == CurrentMagicTarget then
        cleanupMagicMonitor()
    end
end)

local function ShootAtTargetMagicHC(target)
    if not target or not target.Character then 
        return false 
    end
    
    local hitpart = GetMagicBulletHitpart(target)
    if not hitpart then 
        return false 
    end
    
    local Player = game:GetService("Players").LocalPlayer
    if not Player or not Player.Character then 
        return false 
    end
    
    local HRP = Player.Character:FindFirstChild("HumanoidRootPart")
    if not HRP then 
        return false 
    end

    -- Set up monitor for this target
    setupMagicTargetMonitor(target)

    local targetPos = hitpart.Position
    if getgenv().Zero.Resolver.Enabled then
        local resolved = ResolvePosition(target.Character)
        if resolved and typeof(resolved) == "Vector3" then
            targetPos = resolved
        end
    end

    local args = {
        [1] = "Shoot",
        [2] = {
            [1] = {
                [1] = { Normal = targetPos, Instance = hitpart, Position = targetPos },
                [2] = { Normal = targetPos, Instance = hitpart, Position = targetPos },
                [3] = { Normal = targetPos, Instance = hitpart, Position = targetPos },
                [4] = { Normal = targetPos, Instance = hitpart, Position = targetPos },
                [5] = { Normal = targetPos, Instance = hitpart, Position = targetPos }
            },
            [2] = {
                [1] = { thePart = hitpart, theOffset = Vector3.new(0,0,0) },
                [2] = { thePart = hitpart, theOffset = Vector3.new(0,0,0) },
                [3] = { thePart = hitpart, theOffset = Vector3.new(0,0,0) },
                [4] = { thePart = hitpart, theOffset = Vector3.new(0,0,0) },
                [5] = { thePart = hitpart, theOffset = Vector3.new(0,0,0) }
            },
            [3] = HRP.Position,
            [4] = HRP.Position,
            [5] = workspace:GetServerTimeNow()
        }
    }

    local success = pcall(function()
        game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(args))
    end)
    
    return success
end

-- Update the ShootAtTargetMagicDH function
local function ShootAtTargetMagicDH(target)
    if not target or not target.Character then 
        return false 
    end
    
    local hitpart = GetMagicBulletHitpart(target)
    if not hitpart then 
        return false 
    end
    
    local Player = game.Players.LocalPlayer
    if not Player or not Player.Character then 
        return false 
    end
    
    local gun = Player.Character:FindFirstChildOfClass("Tool")
    if not gun or not gun:FindFirstChild("Handle") then 
        return false 
    end
    
    local HRP = Player.Character:FindFirstChild("HumanoidRootPart")
    if not HRP then 
        return false 
    end
    
    -- Set up monitor for this target
    setupMagicTargetMonitor(target)
    
    local targetPos = hitpart.Position
    if getgenv().Zero.Resolver.Enabled then
        local resolved = ResolvePosition(target.Character)
        if resolved and typeof(resolved) == "Vector3" then
            targetPos = resolved
        end
    end

    local success = pcall(function()
        game:GetService("ReplicatedStorage").MainEvent:FireServer(
            "ShootGun",
            gun.Handle,
            HRP.Position,
            targetPos,
            hitpart,
            Vector3.new(0,0,-1)
        )
    end)
    
    return success
end


local function GetClosestVisibleTarget()
    local mousePos = UserInputService:GetMouseLocation()
    local closestPlayer = nil
    local closestDist = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Client and player.Character then
            local char = player.Character
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hrp or not hum then continue end

            -- KO check
            if getgenv().Zero.Ragebot.Checks.Ko and IsKO(char, getgenv().Zero.Ragebot.Checks.Health_limit) then
                continue
            end

            -- Wall check
            if getgenv().Zero.Ragebot.Checks.Wall and not WallCheck(hrp.Position, {Client, char}) then
                continue
            end

            -- Screen check
            local screenPos, onScreen = Cam:WorldToScreenPoint(hrp.Position)
            if not onScreen or screenPos.Z <= 0 then continue end

            -- Distance to mouse
            local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
            if dist < closestDist then
                closestDist = dist
                closestPlayer = player
            end
        end
    end

    return closestPlayer
end


GetSilentTarget = function()
    local referencePos
    

    if IsMobile() then
   
        local vp = workspace.CurrentCamera.ViewportSize
        referencePos = Vector2.new(vp.X / 2, vp.Y / 2)
    else
     
        referencePos = UserInputService:GetMouseLocation()
    end
    
    local closestPlayer
    local closestDist = math.huge
    local resolvedPart = nil

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Client and player.Character then
            local char = player.Character
            local hum = char:FindFirstChild("Humanoid")
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hum or not hrp then continue end

            -- KO check
            if getgenv().Zero.Silent.Checks.Ko and IsKO(char, getgenv().Zero.Silent.Checks.Health_limit) then
                continue
            end

            -- Get resolved position
            local targetPos = hrp.Position
            if getgenv().Zero.Resolver.Enabled then
                local resolved = ResolvePosition(char)
                if resolved then
                    targetPos = resolved
                end
            end

            -- Wall check (use resolved position)
            if getgenv().Zero.Silent.Checks.Wall and not WallCheck(targetPos, {Client, char}) then
                continue
            end

            -- Screen point (use resolved position)
            local pos, onScreen = Cam:WorldToViewportPoint(targetPos)
            if not onScreen or pos.Z <= 0 then continue end

            local dist = (Vector2.new(pos.X, pos.Y) - referencePos).Magnitude

            -- FOV check
            if getgenv().Zero.Silent.FOV.Enabled and dist > getgenv().Zero.Silent.FOV.Radius then
                continue
            end

            if dist < closestDist then
                closestDist = dist
                closestPlayer = char
            end
        end
    end

    if not closestPlayer then return nil end


    if getgenv().Zero.Silent.Closesthitpart then

        local part = GetClosestPartToMouse(closestPlayer)
        if part then
            return part
        else

            return closestPlayer:FindFirstChild(getgenv().Zero.Silent.Hitpart)
        end
    else

        local hum = closestPlayer:FindFirstChildOfClass("Humanoid")
        local hitpartName = getgenv().Zero.Silent.Hitpart
        

        if hum and hum.FloorMaterial == Enum.Material.Air then
            hitpartName = getgenv().Zero.Silent.Airhitpart
        end
        
        return closestPlayer:FindFirstChild(hitpartName)
    end
end






local TracerLine = Drawing.new("Line")
TracerLine.Thickness = 0.1
TracerLine.Transparency = 1
TracerLine.Color = getgenv().Zero.Ragebot.Others.Tracer.Color
TracerLine.Visible = false
local TracerHeight = 0

RunService.Heartbeat:Connect(function()
	if not getgenv().Zero.Ragebot.Others.Tracer.Enabled then
		TracerLine.Visible = false
		return
	end
    if LockedOn and CurrentTarget and CurrentTarget.Character then
        local hrp = CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local tracerWorldPos = hrp.Position + Vector3.new(0, TracerHeight, 0)
            local screenPos = Cam:WorldToViewportPoint(tracerWorldPos)
            if screenPos.Z > 0 then
                TracerLine.From = Vector2New(Cam.ViewportSize.X/2, Cam.ViewportSize.Y/2)
                TracerLine.To = Vector2New(screenPos.X, screenPos.Y)
                TracerLine.Color = getgenv().Zero.Ragebot.Others.Tracer.Color
                TracerLine.Visible = true
            else
                TracerLine.Visible = false
            end
        else
            TracerLine.Visible = false
        end
    else
        TracerLine.Visible = false
    end
end)

-- Bullet TP System
local bulletTPActive = false
local savedTPPosition = nil

local function performBulletTP(targetChar)
    if not getgenv().Zero.Ragebot.BulletTP then return false end
    if not targetChar then return false end
    
    local myChar = Client.Character
    if not myChar then return false end
    
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
    
    if not myHRP or not targetHRP then return false end
    
    -- Save current position
    savedTPPosition = myHRP.CFrame
    
    -- TP to target (slightly behind them)
    local targetPos = targetHRP.Position + Vector3.new(0, 2, 0)
    desync.Pos = CFrame.new(targetPos)
    desync.Mode = "Teleport"
    desync.Enabled = true
    bulletTPActive = true
    
    return true
end

local function returnFromBulletTP()
    if not bulletTPActive then return end
    
    task.wait(0.05) -- Small delay to ensure shot registers
    
    if savedTPPosition then
        desync.Pos = savedTPPosition
        desync.Mode = "Teleport"
        desync.Enabled = true
        
        task.wait(0.1)
        desync.Enabled = false
    end
    
    bulletTPActive = false
    savedTPPosition = nil
end


local _zeroHITconnection = nil

local function setupHitSound(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return end
    local hum = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not hum then return end


    if _zeroHITconnection then
        _zeroHITconnection:Disconnect()
        _zeroHITconnection = nil
    end

    local lastHealth = hum.Health

    _zeroHITconnection = hum.HealthChanged:Connect(function(newHealth)
        if newHealth < lastHealth then
            local root = targetPlayer.Character:FindFirstChild("HumanoidRootPart")

            if getgenv().Zero.Ragebot.Others.HitSound and root then
                local soundTable = {
					neverlose = 6534948092,
                    coin = 3125624765,
                    pop = 6586979979,
                    error = 550209561,
                    click = 87437544236708,
                    snipe = 137392628136734,
                    uwu = 8323804973,
                    retro = 118157652132357,
                    sf = 91656203252586
                }
                local soundId = soundTable[getgenv().Zero.Ragebot.Others.Sound] or 6534948092
                pcall(function()
                    local sound = Instance.new("Sound")
                    sound.SoundId = "rbxassetid://"..soundId
                    sound.Volume = 555555555555
                    sound.PlayOnRemove = true
                    sound.Parent = root
                    sound:Destroy()
                end)
            end
        end
        lastHealth = newHealth
    end)
end


RunService.Heartbeat:Connect(function()
    if LockedOn and CurrentTarget then
        if getgenv().Zero.Ragebot.Checks.Ko then
            if IsKO(CurrentTarget.Character, getgenv().Zero.Ragebot.Checks.Health_limit) then

				LockedOn = false
                CurrentTarget = nil
                RagebotReady = false
          
                 if desyncwasenabled then
		desync.Enabled = false
		task.wait(0.35)
        desync.Enabled = true
       if getgenv().Zero.Self.Voidhide.VoidMode == "Spam" then 
        desync.Mode = "Void Spam"
        else
            desync.Mode = "Void"
        end
        desyncwasenabled = false
    else
        desync.Enabled = false
    end
                
                
                
                if _zeroHITconnection then
                    _zeroHITconnection:Disconnect()
                    _zeroHITconnection = nil
                end
            end
        end
    end
end)



local function UseSpecialRagebotHC()
    return getgenv().Zero.Ragebot.Enabled
        and getgenv().Zero.Ragebot.Autofire
        and HoodcustomsId[game.PlaceId]
end
local function UseSpecialRagebotDH()
    return getgenv().Zero.Ragebot.Enabled
        and getgenv().Zero.Ragebot.Autofire
        and DahoodId[game.PlaceId]
end

local function ShootAtTargetSystemHC(target)
    local Target = target.Character:FindFirstChild("Head")
    local Player = game:GetService("Players").LocalPlayer

    local args = {
        [1] = "Shoot",
        [2] = {
            [1] = {
                [1] = { Normal = Target.Position, Instance = Target, Position = Target.Position },
                [2] = { Normal = Target.Position, Instance = Target, Position = Target.Position },
                [3] = { Normal = Target.Position, Instance = Target, Position = Target.Position },
                [4] = { Normal = Target.Position, Instance = Target, Position = Target.Position },
                [5] = { Normal = Target.Position, Instance = Target, Position = Target.Position }
            },
            [2] = {
                [1] = { thePart = Target, theOffset = Vector3.new(0,0,0) },
                [2] = { thePart = Target, theOffset = Vector3.new(0,0,0) },
                [3] = { thePart = Target, theOffset = Vector3.new(0,0,0) },
                [4] = { thePart = Target, theOffset = Vector3.new(0,0,0) },
                [5] = { thePart = Target, theOffset = Vector3.new(0,0,0) }
            },
            [3] = Player.Character.HumanoidRootPart.Position,
            [4] = Player.Character.HumanoidRootPart.Position,
            [5] = workspace:GetServerTimeNow()
        }
    }

    game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(args))
end

local function ShootAtTargetSystemDH(target,gun)
local Target = target

    game:GetService("ReplicatedStorage").MainEvent:FireServer(
        "ShootGun",
        gun.Handle,
        game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart").Position,
        Target:FindFirstChild("HumanoidRootPart").Position,
        Target:FindFirstChild("Head"),
        Vector3.new(0,0,-1)
    )
end

local function ShootMultiGunsDH(targetChar)
    -- First check: return if multigun not enabled
    if not getgenv().Zero.Ragebot.Multigun then 
        return 
    end
    
    -- Second check: return if not Da Hood
    if not DahoodId[game.PlaceId] then
        return
    end
    
    -- Validate target character
    if not targetChar then return end
    
    local backpack = LocalPlayer.Backpack
    if not backpack then return end
    
    local myChar = LocalPlayer.Character
    if not myChar then return end
    
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
    local targetHead = targetChar:FindFirstChild("Head")
    
    if not myHRP or not targetHRP or not targetHead then return end
    
    task.spawn(function()
        -- Check if there are any guns in backpack
        local gunsInBackpack = false
        for _, tool in ipairs(backpack:GetChildren()) do
            local ammo = tool:FindFirstChild("Ammo")
            if ammo and ammo.Value ~= nil then
                gunsInBackpack = true
                break
            end
        end
        
        -- If guns are in backpack, equip them all first
        if gunsInBackpack then
            for _, gun in ipairs(backpack:GetChildren()) do
                local ammo = gun:FindFirstChild("Ammo")
                if not ammo or ammo.Value == nil then 
                    continue 
                end
                
                gun.Parent = myChar
                task.wait(0.05)
            end
        end
        
        -- Now fire remotes for all equipped guns
        for _, gun in ipairs(myChar:GetChildren()) do
            if gun:IsA("Tool") then
                local ammo = gun:FindFirstChild("Ammo")
                if ammo and ammo.Value ~= nil then
                    pcall(function()
                        game:GetService("ReplicatedStorage").MainEvent:FireServer(
                            "ShootGun",
                            gun.Handle,
                            myHRP.Position,
                            targetHRP.Position,
                            targetHead,
                            Vector3.new(0,0,-1)
                        )
                    end)
                    task.wait(0.05)
                end
            end
        end
    end)
end



local CachedRageCF = nil
local CachedSilentCF = nil

local hitOptions = {"Head", "UpperTorso", "LowerTorso", "HumanoidRootPart"}


local mt = getrawmetatable(game)
local oldIndex = mt.__index
local oldNamecall = mt.__namecall
setreadonly(mt, false)


RunService.RenderStepped:Connect(function()
    CachedRageCF = nil

    if Zero.Ragebot.Enabled and LockedOn and CurrentTarget then
        local char = CurrentTarget.Character
        if char and not (Zero.Ragebot.Checks.Ko and IsKO(char, Zero.Ragebot.Checks.Health_limit)) then
            local partName = Zero.Ragebot.Hitpart
            if Zero.Ragebot.RandomHitPart then
                partName = hitOptions[math.random(1, #hitOptions)]
            end

            local part = char:FindFirstChild(partName)
            if part then
                RagebotReady = true
                CachedRageCF = part.CFrame
            end
        end
    end
end)


RunService.RenderStepped:Connect(function()
    CachedSilentCF = nil

    if Zero.Silent.Enabled and not Zero.Silent.MagicBullet then
        local part = GetSilentTarget()
        if part then
            CachedSilentCF = part.CFrame
          
            local targetChar = part.Parent
            if targetChar then
                local targetPlayer = Players:GetPlayerFromCharacter(targetChar)
                if targetPlayer then
                    setupSilentHitSound(targetPlayer)
                end
            end
        else
        
            if _silentHitConnection then
                _silentHitConnection:Disconnect()
                _silentHitConnection = nil
                _currentSilentTarget = nil
            end
        end
    else
        
        if _silentHitConnection then
            _silentHitConnection:Disconnect()
            _silentHitConnection = nil
            _currentSilentTarget = nil
        end
    end
end)


mt.__index = newcclosure(function(self, key) 
    if checkcaller() then
        return oldIndex(self, key)
    end


    if self ~= Mouse then
        return oldIndex(self, key)
    end

    if key ~= "Hit" and key ~= "hit" then
        return oldIndex(self, key)
    end


    if UseSpecialRagebotHC() or UseSpecialRagebotDH() then
        return oldIndex(self, key)
    end


    if getgenv().Zero.Silent.Enabled and getgenv().Zero.Silent.MagicBullet then
        return oldIndex(self, key)
    end

    if CachedRageCF then
        if getgenv().Zero.Resolver.Enabled
            and CurrentTarget
            and CurrentTarget.Character
        then
            local resolved = ResolvePosition(CurrentTarget.Character)
            if typeof(resolved) == "Vector3" then
                return CFrame.new(resolved)
            end
        end
        return CachedRageCF
    end


    if CachedSilentCF then
        if getgenv().Zero.Resolver.Enabled then
            local pos = CachedSilentCF.Position
            for _, player in ipairs(Players:GetPlayers()) do
                local char = player.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                if hrp and (hrp.Position - pos).Magnitude < 5 then
                    local resolved = ResolvePosition(char)
                    if typeof(resolved) == "Vector3" then
                        return CFrame.new(resolved)
                    end
                end
            end
        end
        return CachedSilentCF
    end

    return oldIndex(self, key)
end)



local CachedMagicTarget = nil
local CachedTargetValid = false

game:GetService("RunService").Heartbeat:Connect(function()
    if getgenv().Zero.Silent.Enabled and getgenv().Zero.Silent.MagicBullet then
        local target = GetClosestToMouseMagic()
        CachedMagicTarget = target
      
        CachedTargetValid = false
        if target then
            local char = target.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum and hum.Health > 0 then
                    CachedTargetValid = true
                end
            end
        end
    else
        CachedMagicTarget = nil
        CachedTargetValid = false
    end
end)


mt.__namecall = newcclosure(function(self, ...) 
    local args = {...}
    local method = getnamecallmethod()

  
    if method == "FireServer"
        and not checkcaller()
        and getgenv().Zero.Silent.Enabled
        and getgenv().Zero.Silent.MagicBullet
        and not SilentFiring
        and self.Name == "MainEvent"
    then
        local isHC = HoodcustomsId[game.PlaceId]
        local isDH = DahoodId[game.PlaceId]
        
        if (isHC and args[1] == "Shoot") or (isDH and args[1] == "ShootGun") then
          
            if CachedTargetValid and CachedMagicTarget then
                SilentFiring = true
             
                local success = isHC and ShootAtTargetMagicHC(CachedMagicTarget) 
                                      or ShootAtTargetMagicDH(CachedMagicTarget)
                
                SilentFiring = false
                
                if success then
                    return nil 
                end
            end
        end
    end

    return oldNamecall(self, ...)
end)
setreadonly(mt, true)

local wallCheckTick = 0
local WALL_CHECK_INTERVAL = 0.05 

RunService.RenderStepped:Connect(function()
    if not UseSpecialRagebotHC() then return end
    if not LockedOn then return end

    local target = CurrentTarget
    if not target then return end

    local char = target.Character
    if not char then return end
     
    hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    if getgenv().Zero.Ragebot.Checks.Wall then
        local now = os.clock()
        if now - wallCheckTick >= WALL_CHECK_INTERVAL then
            wallCheckTick = now
            if not WallCheck(hrp.Position, {Client.Character, char}) then
                return
            end
        end
    end
    
    if char:FindFirstChildOfClass("ForceField") then
        return
    end
    
    -- Bullet TP - TP FIRST, then shoot
    if getgenv().Zero.Ragebot.BulletTP then
        local myChar = Client.Character
        local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
        local targetHRP = char:FindFirstChild("HumanoidRootPart")
        
        if myHRP and targetHRP then
            -- Save position
            local savedPos = myHRP.CFrame
            
            -- TP to target
            local targetPos = targetHRP.Position + Vector3.new(0, 2, 0)
            desync.Pos = CFrame.new(targetPos)
            desync.Mode = "Teleport"
            desync.Enabled = true
            
            -- Wait for TP to register
            task.wait(0.05)
            
            -- NOW shoot
            ShootAtTargetSystemHC(target)
            
            -- TP back
            task.wait(0.05)
            desync.Pos = savedPos
            desync.Enabled = true
            task.wait(0.1)
            desync.Enabled = false
            
            return
        end
    end
    
    -- Normal shooting if bullet TP is off
    ShootAtTargetSystemHC(target)
end)

RunService.RenderStepped:Connect(function()
    if not UseSpecialRagebotDH() then return end  -- Ragebot-only gate
    if not LockedOn then return end
    local target = CurrentTarget
    if not target or not target.Character then return end
    local char = target.Character
    if char:FindFirstChildOfClass("ForceField") then return end
    
    -- Your wall/HRP checks...
    hrp = char:FindFirstChild("HumanoidRootPart")
    if getgenv().Zero.Ragebot.Checks.Wall then
        -- ... your wall code ...
    end
    
    -- Bullet TP (MultiGun compatible)
    if getgenv().Zero.Ragebot.BulletTP then
        -- ... your TP code ...
        -- In shoot spot:
        if getgenv().Zero.Ragebot.Multigun then
          ShootMultiGunsDH(char)
        else
            ShootAtTargetSystemDH(char, game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"))
        end
        return
    end
    
    -- NORMAL RAGE SHOOT: Multi or Single
    if getgenv().Zero.Ragebot.Multigun then
        ShootMultiGunsDH(char)
    else
        ShootAtTargetSystemDH(char, game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"))
    end
end)


-- autofire
game:GetService("RunService").Heartbeat:Connect(function()
        if getgenv().Zero.Ragebot.Autofire
            and LockedOn
            and CurrentTarget
            and CurrentTarget.Character
            and not UseSpecialRagebotHC() 
            and not UseSpecialRagebotDH() then 
            local tool = Client.Character:FindFirstChildOfClass("Tool")
            if tool and tool.Name ~= "[Knife]" then
                tool:Activate()
            end
        end
   
end)




--// TOGGLE RAGEBOT
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode ~= getgenv().Zero.Ragebot.Keybind then return end
    if not getgenv().Zero.Ragebot.Enabled then return end

    if LockedOn then

		LockedOn = false
        CurrentTarget = nil
        RagebotReady = false
        -- UNLOCKING
         if desyncwasenabled then
		desync.Enabled = false
		task.wait(0.35)
        desync.Enabled = true
        if getgenv().Zero.Self.Voidhide.VoidMode == "Spam" then 
        desync.Mode = "Void Spam"
        else
            desync.Mode = "Void"
        end
        desyncwasenabled = false
    else
        desync.Enabled = false
    end
        
        
        if _zeroHITconnection then
            _zeroHITconnection:Disconnect()
            _zeroHITconnection = nil
        end

else
    local target = GetClosestVisibleTarget()
    if target then
        if desync.Enabled then
            desync.Enabled = false
            desyncwasenabled = true
        end
        LockedOn = true
        CurrentTarget = target
        if IsKO(CurrentTarget.Character, getgenv().Zero.Ragebot.Checks.Health_limit) then
            LockedOn = false
            CurrentTarget = nil
            RagebotReady = false
            return
        end
        if getgenv().Zero.Ragebot.FollowTarget.Enabled then
            local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = Client.Character and Client.Character:FindFirstChild("HumanoidRootPart")
            if targetHRP and myHRP then
                local radius = getgenv().Zero.Ragebot.FollowTarget.Radius
                local offsetX = math.random(-radius, radius)
                local offsetZ = math.random(-radius, radius)
                local offsetY = 5
                local targetPos = targetHRP.Position + Vector3.new(offsetX, offsetY, offsetZ)
                local rotation = myHRP.CFrame - myHRP.CFrame.Position
                
                desync.Pos = CFrame.new(targetPos) * rotation
                desync.Mode = "Teleport"
                desync.Enabled = true
            end
        end
        
        setupHitSound(target)
    end
end
end)

--// CFRAME SPEED
local active = false
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode ==  getgenv().Zero.Self.CFrameSpeed.Keybind and getgenv().Zero.Self.CFrameSpeed.Enabled then
        active = not active
    end
end)

RunService.Heartbeat:Connect(function()
    if not active or not getgenv().Zero.Self.CFrameSpeed.Enabled then return end
    local character = Client.Character
    if not character then return end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    local hum = character:FindFirstChild("Humanoid")
    if not hrp or not hum then return end

    if hum.MoveDirection.Magnitude > 0 then
        hrp.CFrame += hum.MoveDirection * getgenv().Zero.Self.CFrameSpeed.Speed
    end
end)

local RunService = game:GetService("RunService")


local strafeAngle = 0
local heightOffset = 0
local speed = 20
local lerpSpeed = 0.3


local lastUpdate = 0
local updateInterval = 0.0001

RunService.Heartbeat:Connect(function(dt)
    if not getgenv().Zero.Ragebot.FollowTarget.Enabled then return end
    if not LockedOn or not CurrentTarget or not CurrentTarget.Character then return end

    local targetHRP = CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
    local myHRP = Client.Character and Client.Character:FindFirstChild("HumanoidRootPart")
    if not targetHRP or not myHRP then return end

    lastUpdate = lastUpdate + dt
    if lastUpdate < updateInterval then return end
    lastUpdate = 0

    if getgenv().Zero.Ragebot.FollowTarget.Mode == "Random" then
        local radius = getgenv().Zero.Ragebot.FollowTarget.Radius
        local offsetX = math.random(-radius, radius)
        local offsetZ = math.random(-radius, radius)
        local offsetY = 5

        local targetPos = targetHRP.Position + Vector3.new(offsetX, offsetY, offsetZ)
        local rotation = desync.Pos and (desync.Pos - desync.Pos.Position) or (myHRP.CFrame - myHRP.CFrame.Position)

        desync.Pos = CFrame.new(targetPos) * rotation
        desync.Mode = "Teleport" 
        desync.Enabled = true     
    end
end)


function LocateArmor()
    for i,v in pairs(game:GetDescendants()) do
    if v:IsA("ClickDetector") and v.Parent.Name:match("Armor") then
        local savedpos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
        task.wait(0.05)
        desync.Pos = v.Parent.Head.CFrame
		desync.Mode = "Teleport"
		desync.Enabled = true
		task.wait(0.2)
   fireclickdetector(v)
        task.wait(0.1)
        desync.Enabled = false
   return
    end
end
end


game:GetService("UserInputService").InputBegan:Connect(function(input, p)
    if p then return end
    if input.KeyCode == getgenv().Zero.Otherslol.Armorkeybind then
    LocateArmor()
    end
end)

local vhtoggled = false
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
	if not getgenv().Zero.Self.Voidhide.Enabled then return end
    if input.KeyCode == getgenv().Zero.Self.Voidhide.Keybind then
        vhtoggled = not vhtoggled
		
		if getgenv().Zero.Self.Voidhide.VoidMode == "Normal" then
			desync.Mode = "Void"
			desync.Enabled = vhtoggled
		elseif getgenv().Zero.Self.Voidhide.VoidMode == "Spam" then
			desync.Mode = "Void Spam"
			desync.Enabled = vhtoggled
		end
    end
end)

-- services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

-- config
local emoteid = "rbxassetid://70883871260184"
local freezetime = 0.1265

-- state

local active = false
local track, heartbeat, animconn

-- helpers
local function getHumanoid()
    local char = player.Character or player.CharacterAdded:Wait()
    return char:WaitForChild("Humanoid")
end

local function cleanup()
    if track then track:Stop(); track:Destroy(); track = nil end
    if heartbeat then heartbeat:Disconnect(); heartbeat = nil end
    if animconn then animconn:Disconnect(); animconn = nil end
end

local function startGod()
    if active then return end
    active = true

    local hum = getHumanoid()
    if not hum then return end

    cleanup()

    local anim = Instance.new("Animation")
    anim.AnimationId = emoteid
    track = hum:LoadAnimation(anim)
    track:Play(0, 1, 1)

    heartbeat = RunService.Heartbeat:Connect(function()
        if active and track then
            track.TimePosition = freezetime
            track:AdjustSpeed(0)
        end
    end)

    animconn = hum.AnimationPlayed:Connect(function(newTrack)
        if active and track and newTrack ~= track then
            task.delay(0.02 + math.random() * 0.03, startGod)
        end
    end)
end

local function stopGod()
    active = false
    cleanup()
end

-- 🔥 public function
function togglegod(state)
    if state then
        startGod()
    else
        stopGod()
    end
end

-- reapply on respawn
player.CharacterAdded:Connect(function()
    task.wait(0.25)
    if active then startGod() end
end)




local guns = {
    ['Aug'] = ("[AUG]"),
	['Double Barrel'] = ("[Double-Barrel SG]"),
    ['Double Barrel For Other Games'] = ("[DoubleBarrel]"),
    ['Shotgun'] = ("[Shotgun]"),
    ['Tactical Shotgun'] = ("[TacticalShotgun]"),
	['Revolver'] = ("[Revolver]")
}


local function GetClosestPlayerInRadius(radius)
    local myChar = Client.Character
    if not myChar then return nil end
    
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end
    
    local closestPlayer = nil
    local closestDist = radius
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Client and player.Character then
            local char = player.Character
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local hum = char:FindFirstChildOfClass("Humanoid")
            
            if hrp and hum then
                -- KO check (optional, you can add this if you want)
                if getgenv().Zero.Ragebot.Checks.Ko and IsKO(char, getgenv().Zero.Ragebot.Checks.Health_limit) then
                    continue
                end
                
                -- Calculate distance
                local dist = (myHRP.Position - hrp.Position).Magnitude
                
                if dist <= closestDist then
                    closestDist = dist
                    closestPlayer = player
                end
            end
        end
    end
    
    return closestPlayer, closestDist
end

-- Kill Aura Loop
RunService.RenderStepped:Connect(function()
    if not getgenv().Zero.Ragebot.Kill_Aura.Enabled then return end
    
    local radius = getgenv().Zero.Ragebot.Kill_Aura.Radius
    local mode = getgenv().Zero.Ragebot.Kill_Aura.Mode
    local HasAUG = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool") and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Name == guns['Aug']
    local targetPlayer, distance = GetClosestPlayerInRadius(radius)
    
    -- Check if current target is out of radius
    if CurrentTarget and CurrentTarget.Character then
        local myHRP = Client.Character and Client.Character:FindFirstChild("HumanoidRootPart")
        local targetHRP = CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        
        if myHRP and targetHRP then
            local currentDist = (myHRP.Position - targetHRP.Position).Magnitude
            if currentDist > radius then
                CurrentTarget = nil
                LockedOn = false
            end
        else
            -- Target's HRP doesn't exist (died/despawned)
            CurrentTarget = nil
            LockedOn = false
        end
    end
    
    if not targetPlayer then return end
    getgenv().Zero.Ragebot.Enabled = true
    getgenv().Zero.Ragebot.Autofire = true
    if mode == "Aug" then
        if HasAUG then 
            CurrentTarget = targetPlayer
            LockedOn = true
        else 
            local hastool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
            if hastool then
                hastool.Parent = game.Players.LocalPlayer.Backpack
            end
            local augnig = game.Players.LocalPlayer.Backpack:FindFirstChild(guns['Aug'])
            if augnig then
                augnig.Parent = game.Players.LocalPlayer.Character
            end
            return
        end
        
    elseif mode == "Normal" then
        CurrentTarget = targetPlayer
        LockedOn = true
    end
end)

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- ────────────────────────────────────────────────
--  Pink Forcefield (Self Visuals) variables
-- ────────────────────────────────────────────────
local ff_color = Color3.fromRGB(255, 0, 255)       -- default magenta/pink
local ff_transparency = 0.2
local ff_enabled = false                           -- starts OFF

local originals = {}                               -- [character] → {parts = {}, surfaces = {}}

local allowedParts = {
    Head = true,
    UpperTorso = true,
    LowerTorso = true,
    HumanoidRootPart = false,
    LeftUpperArm = true,    RightUpperArm = true,
    LeftLowerArm = true,    RightLowerArm = true,
    LeftHand = true,        RightHand = true,
    LeftUpperLeg = true,    RightUpperLeg = true,
    LeftLowerLeg = true,    RightLowerLeg = true,
    LeftFoot = true,        RightFoot = true
}

local function shouldAffect(part)
    if not part:IsA("BasePart") then return false end
    if part.Name == "HumanoidRootPart" then return false end
    if allowedParts[part.Name] then return true end
    return part:FindFirstAncestorOfClass("Accessory") ~= nil
end

local function applyForcefield(character, enable)
    enable = enable ~= false
    local data = originals[character]

    if enable then
        -- Store current state → apply
        data = { parts = {}, surfaces = {} }
        originals[character] = data

        for _, obj in pairs(character:GetDescendants()) do
            if shouldAffect(obj) then
                data.parts[obj] = {
                    Material = obj.Material,
                    Color = obj.Color,
                    Transparency = obj.Transparency
                }
                obj.Material = Enum.Material.ForceField
                obj.Color = ff_color
                obj.Transparency = ff_transparency
            elseif obj:IsA("Decal") or obj:IsA("Texture") then
                local parent = obj.Parent
                if parent and shouldAffect(parent) then
                    data.surfaces[obj] = { Transparency = obj.Transparency }
                    obj.Transparency = 1
                end
            end
        end
    else
        -- Restore
        if data then
            for part, props in pairs(data.parts) do
                if part and part.Parent then
                    part.Material     = props.Material
                    part.Color        = props.Color
                    part.Transparency = props.Transparency
                end
            end
            for surf, props in pairs(data.surfaces) do
                if surf and surf.Parent then
                    surf.Transparency = props.Transparency
                end
            end
        end
    end
end

-- Apply / re-apply logic
local function refreshForcefield()
    if not ff_enabled then return end
    if player.Character then
        applyForcefield(player.Character, true)
    end
end

player.CharacterAdded:Connect(function(char)
    char:WaitForChild("HumanoidRootPart", 5)
    refreshForcefield()
end)

player.CharacterRemoving:Connect(function(char)
    originals[char] = nil
end)

-- Initial apply if already spawned
if player.Character then
    refreshForcefield()
end

-- ====================================================================
--  COMPLETE WORLD VISUALS MODULE - PASTE THIS INTO YOUR ZERO SCRIPT
--  Place this RIGHT AFTER getgenv().Zero = {...}
-- ====================================================================

local WorldVisuals = {}
WorldVisuals.__index = WorldVisuals

-- Helper functions
local function find_first_child_of_class(parent, className)
    for _, child in pairs(parent:GetChildren()) do
        if child:IsA(className) then
            return child
        end
    end
    return nil
end

local function create_instance(className, properties)
    local instance = Instance.new(className)
    for prop, value in pairs(properties) do
        instance[prop] = value
    end
    return instance
end

-- Initialize module
function WorldVisuals.new()
    local self = setmetatable({}, WorldVisuals)
    
    local Lighting = game:GetService("Lighting")
    local Workspace = game:GetService("Workspace")
    local MaterialService = game:GetService("MaterialService")
    
    -- Store original values
    self.original = {
        ClockTime = Lighting.ClockTime,
        Technology = Lighting.Technology,
        TimeOfDay = Lighting.TimeOfDay,
        Ambient = Lighting.Ambient,
        OutdoorAmbient = Lighting.OutdoorAmbient,
    }
    
    -- Current state
    self.enabled = false
    self.atmosphere = nil
    self.weather_part = nil
    self.weather_particle = nil
    self.heartbeat_connection = nil
    self.texture_connection = nil
    self.world_time_connection = nil
    self.texture_variants = {}
    self.texture_restores = {}
    
    -- Get references
    self.sky = find_first_child_of_class(Lighting, "Sky")
    self.color_correction = find_first_child_of_class(Lighting, "ColorCorrectionEffect")
    
    -- Configuration
    self.config = {
        world_time = {
            enabled = false,
            hour = 4.5
        },
        atmosphere = {
            enabled = false,
            color = Color3.fromRGB(255, 255, 255),
            decay = Color3.fromRGB(120, 120, 120),
            haze = 1,
            glare = 10,
            offset = 0,
            density = 0.35
        },
        saturation = {
            enabled = false,
            value = 0.1
        },
        contrast = {
            enabled = false,
            value = 0.05
        },
        textures = {
            enabled = false,
            pack = "minecraft"
        },
        ambient = {
            enabled = false,
            indoor_color = Lighting.Ambient,
            outdoor_color = Lighting.OutdoorAmbient
        },
        weather = {
            enabled = true,
            type = "snow",
            color = Color3.fromRGB(255, 255, 255),
            rate = 100
        },
        skybox = {
            enabled = false,
            preset = "black storm"
        },
        tint = {
            enabled = false,
            color = Color3.fromRGB(255, 255, 255)
        }
    }
    
    -- Skybox presets
    self.skyboxes = {
        ["default"] = {
            SkyboxBk = self.sky.SkyboxBk,
            SkyboxDn = self.sky.SkyboxDn,
            SkyboxFt = self.sky.SkyboxFt,
            SkyboxLf = self.sky.SkyboxLf,
            SkyboxRt = self.sky.SkyboxRt,
            SkyboxUp = self.sky.SkyboxUp,
            SunTextureId = self.sky.SunTextureId,
            MoonTextureId = self.sky.MoonTextureId
        },
        ["stormy"] = {
            SkyboxUp = "http://www.roblox.com/asset/?id=18703232671",
            SkyboxBk = "http://www.roblox.com/asset/?id=18703245834",
            SkyboxLf = "http://www.roblox.com/asset/?id=18703237556",
            SkyboxDn = "http://www.roblox.com/asset/?id=18703243349",
            SkyboxFt = "http://www.roblox.com/asset/?id=18703240532",
            SkyboxRt = "http://www.roblox.com/asset/?id=18703235430",
            SunTextureId = self.sky.SunTextureId,
            MoonTextureId = self.sky.MoonTextureId
        },
        ["blue space"] = {
            SkyboxLf = "rbxassetid://15536114370",
            SkyboxUp = "rbxassetid://15536117282",
            SkyboxRt = "rbxassetid://15536118762",
            SkyboxFt = "rbxassetid://15536116141",
            SkyboxDn = "rbxassetid://15536112543",
            SkyboxBk = "rbxassetid://15536110634",
            SunTextureId = self.sky.SunTextureId,
            MoonTextureId = self.sky.MoonTextureId
        },
        ["pink"] = {
            SkyboxUp = "rbxassetid://12216108877",
            SkyboxLf = "rbxassetid://12216110170",
            SkyboxRt = "rbxassetid://12216110471",
            SkyboxFt = "rbxassetid://12216109489",
            SkyboxBk = "rbxassetid://12216109205",
            SkyboxDn = "rbxassetid://12216109875",
            SunTextureId = self.sky.SunTextureId,
            MoonTextureId = self.sky.MoonTextureId
        },
        ["black storm"] = {
            SkyboxLf = "rbxassetid://15502507918",
            SkyboxUp = "rbxassetid://15502511911",
            SkyboxRt = "rbxassetid://15502509398",
            SkyboxFt = "rbxassetid://15502510289",
            SkyboxDn = "rbxassetid://15502508460",
            SkyboxBk = "rbxassetid://15502511288",
            SunTextureId = self.sky.SunTextureId,
            MoonTextureId = self.sky.MoonTextureId
        },
        ["realistic"] = {
            SkyboxUp = "rbxassetid://653719321",
            SkyboxDn = "rbxassetid://653718790",
            SkyboxLf = "rbxassetid://653719190",
            SkyboxFt = "rbxassetid://653719067",
            SkyboxRt = "rbxassetid://653718931",
            SkyboxBk = "rbxassetid://653719502",
            SunTextureId = self.sky.SunTextureId,
            MoonTextureId = self.sky.MoonTextureId
        }
    }
    
    -- Weather types
    self.weather_types = {
        ["rain"] = {
            Speed = NumberRange.new(60, 60),
            LockedToPart = true,
            Rate = 600,
            Texture = "rbxassetid://1822883048",
            EmissionDirection = Enum.NormalId.Bottom,
            Transparency = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 1),
                NumberSequenceKeypoint.new(0.25, 0.7842668294906616),
                NumberSequenceKeypoint.new(0.75, 0.7842668294906616),
                NumberSequenceKeypoint.new(1, 1)
            },
            Lifetime = NumberRange.new(0.800000011920929, 0.800000011920929),
            LightEmission = 0.05000000074505806,
            LightInfluence = 0.8999999761581421,
            Orientation = Enum.ParticleOrientation.FacingCameraWorldUp,
            Size = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 10),
                NumberSequenceKeypoint.new(1, 10)
            }
        },
        ["snow"] = {
            Transparency = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 0.7374999523162842),
                NumberSequenceKeypoint.new(0.973, 0.768750011920929),
                NumberSequenceKeypoint.new(1, 1)
            },
            Texture = "http://www.roblox.com/asset/?id=99851851",
            SpreadAngle = Vector2.new(50, 50),
            Speed = NumberRange.new(30, 30),
            LightEmission = 0.5,
            Rate = 1000,
            EmissionDirection = Enum.NormalId.Bottom,
            Size = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 0.33096909523010254),
                NumberSequenceKeypoint.new(0.551, 0.40189146995544434),
                NumberSequenceKeypoint.new(1, 0.33096909523010254)
            }
        },
        ["light rain"] = {
            LockedToPart = true,
            Rate = 500,
            Squash = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 3),
                NumberSequenceKeypoint.new(1, 3)
            },
            LightInfluence = 0.30000001192092896,
            Transparency = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(0.435, 0),
                NumberSequenceKeypoint.new(1, 0)
            },
            Texture = "rbxasset://textures/particles/sparkles_main.dds",
            Speed = NumberRange.new(30, 50),
            Lifetime = NumberRange.new(9, 9),
            LightEmission = 0.5,
            Brightness = 2,
            EmissionDirection = Enum.NormalId.Bottom,
            Orientation = Enum.ParticleOrientation.FacingCameraWorldUp,
            Size = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 0.20000000298023224),
                NumberSequenceKeypoint.new(1, 0.20000000298023224)
            }
        }
    }
    
    -- Texture packs
    self.texture_packs = {
        ["minecraft"] = {
            Slate = "http://www.roblox.com/asset/?id=8676746437",
            Grass = "http://www.roblox.com/asset/?id=9267183930",
            Sand = "http://www.roblox.com/asset/?id=12624140843",
            Wood = "http://www.roblox.com/asset/?id=3258599312",
            Brick = "http://www.roblox.com/asset/?id=10777285622",
            Concrete = "http://www.roblox.com/asset/?id=15622710576",
            CorrodedMetal = "rbxassetid://78612695839404",
            Metal = "http://www.roblox.com/asset/?id=121650613091353",
            WoodPlanks = "http://www.roblox.com/asset/?id=8676581022"
        }
    }
    
    return self
end

-- Update configuration
function WorldVisuals:SetConfig(category, settings)
    if not self.config[category] then
        warn("Invalid config category:", category)
        return
    end
    
    for key, value in pairs(settings) do
        self.config[category][key] = value
    end
    
    -- Apply the changes
    if self.enabled then
        self:ApplyConfig(category)
    end
end

-- Apply specific configuration
function WorldVisuals:ApplyConfig(category)
    if category == "world_time" then
        self:UpdateWorldTime()
    elseif category == "atmosphere" then
        self:UpdateAtmosphere()
    elseif category == "saturation" then
        self:UpdateSaturation()
    elseif category == "contrast" then
        self:UpdateContrast()
    elseif category == "textures" then
        self:UpdateTextures()
    elseif category == "ambient" then
        self:UpdateAmbient()
    elseif category == "weather" then
        self:UpdateWeather()
    elseif category == "skybox" then
        self:UpdateSkybox()
    elseif category == "tint" then
        self:UpdateTint()
    end
end

-- World Time
function WorldVisuals:UpdateWorldTime()
    local cfg = self.config.world_time
    local Lighting = game:GetService("Lighting")
    local RunService = game:GetService("RunService")
    
    -- Disconnect old connection
    if self.world_time_connection then
        self.world_time_connection:Disconnect()
        self.world_time_connection = nil
    end
    
    if cfg.enabled then
        -- Constantly set the time to prevent game from changing it back
        self.world_time_connection = RunService.RenderStepped:Connect(function()
            Lighting.ClockTime = cfg.hour
        end)
    else
        Lighting.ClockTime = self.original.ClockTime
    end
end

-- Atmosphere
function WorldVisuals:UpdateAtmosphere()
    local cfg = self.config.atmosphere
    local Lighting = game:GetService("Lighting")
    
    if self.atmosphere then
        self.atmosphere:Destroy()
        self.atmosphere = nil
    end
    
    if cfg.enabled then
        self.atmosphere = create_instance("Atmosphere", {
            Color = cfg.color,
            Density = cfg.density,
            Glare = cfg.glare,
            Haze = cfg.haze,
            Offset = cfg.offset,
            Decay = cfg.decay,
            Parent = Lighting
        })
    end
end

-- Saturation
function WorldVisuals:UpdateSaturation()
    local cfg = self.config.saturation
    if self.color_correction then
        self.color_correction.Saturation = cfg.enabled and cfg.value or 0.1
    end
end

-- Contrast
function WorldVisuals:UpdateContrast()
    local cfg = self.config.contrast
    if self.color_correction then
        self.color_correction.Contrast = cfg.enabled and cfg.value or 0.05
    end
end

-- Textures
function WorldVisuals:UpdateTextures()
    local cfg = self.config.textures
    local Workspace = game:GetService("Workspace")
    local MaterialService = game:GetService("MaterialService")
    
    -- Clean up existing variants
    for i = 1, #self.texture_variants do
        self.texture_variants[i]:Destroy()
        self.texture_variants[i] = nil
    end
    
    -- Restore original colors
    for part, data in pairs(self.texture_restores) do
        if part and part.Parent then
            part.Color = data
        end
        self.texture_restores[part] = nil
    end
    
    if self.texture_connection then
        self.texture_connection:Disconnect()
        self.texture_connection = nil
    end
    
    if not cfg.enabled then
        return
    end
    
    local textures = self.texture_packs[cfg.pack]
    if not textures then
        warn("Invalid texture pack:", cfg.pack)
        return
    end
    
    -- Apply textures
    local white = Color3.fromRGB(254, 253, 255)
    
    local function apply_texture(descendant)
        local class_name = descendant.ClassName
        
        if class_name == "MeshPart" or class_name == "Part" then
            local texture = textures[descendant.Material.Name]
            
            if (texture or descendant.Color == white) and descendant.Transparency < 0.8 then
                if not self.texture_restores[descendant] then
                    self.texture_restores[descendant] = descendant.Color
                    descendant.Color = white
                end
            end
        end
    end
    
    -- Create material variants
    for name, id in pairs(textures) do
        if name ~= "Glass" then
            local material = create_instance("MaterialVariant", {
                MetalnessMap = id,
                NormalMap = id,
                BaseMaterial = Enum.Material[name],
                Name = name,
                StudsPerTile = 5,
                RoughnessMap = id,
                Parent = MaterialService,
                ColorMap = id,
            })
            table.insert(self.texture_variants, material)
        end
    end
    
    -- Apply to existing parts
    if Workspace:FindFirstChild("MAP") then
        local descendants = Workspace.MAP:GetDescendants()
        for i = 1, #descendants do
            apply_texture(descendants[i])
        end
        
        -- Connect for new parts
        self.texture_connection = Workspace.MAP.DescendantAdded:Connect(apply_texture)
    end
end

-- Ambient Lighting
function WorldVisuals:UpdateAmbient()
    local cfg = self.config.ambient
    local Lighting = game:GetService("Lighting")
    
    if cfg.enabled then
        Lighting.Ambient = cfg.indoor_color
        Lighting.OutdoorAmbient = cfg.outdoor_color
    else
        Lighting.Ambient = self.original.Ambient
        Lighting.OutdoorAmbient = self.original.OutdoorAmbient
    end
end

-- Weather
function WorldVisuals:UpdateWeather()
    local cfg = self.config.weather
    local Workspace = game:GetService("Workspace")
    local RunService = game:GetService("RunService")
    
    -- Clean up existing weather
    if self.weather_part then
        self.weather_part:Destroy()
        self.weather_part = nil
        self.weather_particle = nil
    end
    
    if self.heartbeat_connection then
        self.heartbeat_connection:Disconnect()
        self.heartbeat_connection = nil
    end
    
    if not cfg.enabled then
        return
    end
    
    -- Find or create Ignored folder
    local ignored = Workspace:FindFirstChild("Ignored")
    if not ignored then
        -- Try common alternatives
        ignored = Workspace:FindFirstChild("Ignore") 
            or Workspace:FindFirstChild("ignore")
            or Workspace:FindFirstChild("ignored")
        
        -- If still not found, create it
        if not ignored then
            ignored = Instance.new("Folder")
            ignored.Name = "Ignored"
            ignored.Parent = Workspace
            warn("[WorldVisuals] Created Ignored folder in Workspace")
        end
    end
    
    -- Create weather part
    self.weather_part = create_instance("Part", {
        Size = Vector3.new(40, 40, 85),
        CanCollide = false,
        Massless = true,
        CastShadow = false,
        Transparency = 1,
        Anchored = true,
        Name = "WeatherPart",
        Parent = ignored
    })
    
    local data = self.weather_types[cfg.type]
    if not data then
        warn("[WorldVisuals] Invalid weather type:", cfg.type)
        return
    end
    
    -- Copy weather data and apply rate multiplier
    local weather_data = {}
    for k, v in pairs(data) do
        weather_data[k] = v
    end
    weather_data.Rate = data.Rate * (cfg.rate / 100)
    
    -- Create particle emitter
    self.weather_particle = create_instance("ParticleEmitter", weather_data)
    self.weather_particle.Color = ColorSequence.new(cfg.color)
    self.weather_particle.Name = "WeatherParticle"
    self.weather_particle.Enabled = true  -- FORCE ENABLE
    self.weather_particle.Parent = self.weather_part
    
    -- Update position every frame
    local offset = Vector3.new(0, 20, 0)
    
    self.heartbeat_connection = RunService.Heartbeat:Connect(function()
        if not self.weather_part then return end
        
        local camera = Workspace.CurrentCamera
        if camera and camera.CFrame then
            self.weather_part.CFrame = CFrame.new(camera.CFrame.Position + offset)
        end
    end)
    
    print("[WorldVisuals] Weather enabled:", cfg.type, "Rate:", weather_data.Rate)
    print("[WorldVisuals] Weather part created at:", self.weather_part.Position)
    print("[WorldVisuals] Particle enabled:", self.weather_particle.Enabled)
end

-- Skybox
function WorldVisuals:UpdateSkybox()
    local cfg = self.config.skybox
    
    local preset = cfg.enabled and cfg.preset or "default"
    local ids = self.skyboxes[preset]
    
    if not ids then
        warn("Invalid skybox preset:", preset)
        return
    end
    
    if self.sky then
        self.sky.SkyboxBk = ids.SkyboxBk
        self.sky.SkyboxDn = ids.SkyboxDn
        self.sky.SkyboxFt = ids.SkyboxFt
        self.sky.SkyboxLf = ids.SkyboxLf
        self.sky.SkyboxRt = ids.SkyboxRt
        self.sky.SkyboxUp = ids.SkyboxUp
        self.sky.SunTextureId = ids.SunTextureId
        self.sky.MoonTextureId = ids.MoonTextureId
    end
end

-- Tint
function WorldVisuals:UpdateTint()
    local cfg = self.config.tint
    
    if self.color_correction then
        self.color_correction.TintColor = cfg.enabled and cfg.color or Color3.fromRGB(255, 255, 255)
    end
end

-- Start all effects
function WorldVisuals:Start()
    self.enabled = true
    
    -- Apply all configurations
    for category, _ in pairs(self.config) do
        self:ApplyConfig(category)
    end
end

-- Reset all effects
function WorldVisuals:Reset()
    self.enabled = false
    local Lighting = game:GetService("Lighting")
    
    -- Restore lighting
    Lighting.ClockTime = self.original.ClockTime
    Lighting.Technology = self.original.Technology
    Lighting.TimeOfDay = self.original.TimeOfDay
    Lighting.Ambient = self.original.Ambient
    Lighting.OutdoorAmbient = self.original.OutdoorAmbient
    
    -- Disconnect world time loop
    if self.world_time_connection then
        self.world_time_connection:Disconnect()
        self.world_time_connection = nil
    end
    
    -- Clean up atmosphere
    if self.atmosphere then
        self.atmosphere:Destroy()
        self.atmosphere = nil
    end
    
    -- Clean up weather
    if self.weather_part then
        self.weather_part:Destroy()
        self.weather_part = nil
        self.weather_particle = nil
    end
    
    if self.heartbeat_connection then
        self.heartbeat_connection:Disconnect()
        self.heartbeat_connection = nil
    end
    
    -- Clean up textures
    for i = 1, #self.texture_variants do
        self.texture_variants[i]:Destroy()
        self.texture_variants[i] = nil
    end
    
    for part, data in pairs(self.texture_restores) do
        if part and part.Parent then
            part.Color = data
        end
        self.texture_restores[part] = nil
    end
    
    if self.texture_connection then
        self.texture_connection:Disconnect()
        self.texture_connection = nil
    end
    
    -- Reset color correction
    if self.color_correction then
        self.color_correction.Saturation = 0.1
        self.color_correction.Contrast = 0.05
        self.color_correction.TintColor = Color3.fromRGB(255, 255, 255)
    end
    
    -- Reset skybox
    self:UpdateSkybox()
end

-- Destroy and cleanup
function WorldVisuals:Destroy()
    self:Reset()
end

-- Initialize WorldVisuals ONCE
local worldVis = WorldVisuals.new()
worldVis:Start()
-- ====================================================================
--  END OF WORLDVISUALS MODULE
--  Continue with your normal Zero script below...
-- ====================================================================

-- Load the particle aura module
local ParticleAura = loadstring(game:HttpGet("https://raw.githubusercontent.com/24ktokyo02ndbackup-byte/scripts/refs/heads/main/self%20aura%20by%20ai%20lol"))()

ParticleAura.toggle(false)

		
library = loadstring(game:HttpGet("https://raw.githubusercontent.com/i77lhm/vaderpaste/refs/heads/main/library.lua"))()
flags = library.flags	



-- Window
local window = library:window({
    Name = "Zero",
    size = GetSize(),
	background_image = ""
})

-- Tabs
local Main = window:tab({ name = "Main" })
local Localplayertab = window:tab({ name = "Local player" })
local Visuals = window:tab({ name = "Visuals" })
local Configs = window:tab({ name = "Configs" })

-- ========== MAIN TAB ==========

-- Ragebot Section
local Rage = Main:section({ name = "Ragebot", side = "left" })

Rage:toggle({
    name = "Enabled",
    flag = "rage_enabled",
    default = getgenv().Zero.Ragebot.Enabled,
    callback = function(v)
        getgenv().Zero.Ragebot.Enabled = v
    end
})
Rage:keybind({
    name = "Ragebot Key",
    flag = "rage_enabled_bind",
    default = getgenv().Zero.Ragebot.Keybind,
    callback = function()
        getgenv().Zero.Ragebot.Keybind = flags["rage_enabled_bind"].key
end
})

Rage:toggle({
    name = "Auto Fire",
    flag = "rage_autofire",
    default = getgenv().Zero.Ragebot.Autofire,
    callback = function(v)
        getgenv().Zero.Ragebot.Autofire = v
    end
})


Rage:dropdown({
    name = "Hitpart",
    flag = "rage_hitpart",
    items = { "Head", "HumanoidRootPart", "UpperTorso" },
    default = getgenv().Zero.Ragebot.Hitpart,
    multi = false,
    callback = function(v)
        getgenv().Zero.Ragebot.Hitpart = v
    end
})

Rage:toggle({
    name = "Random Hitpart",
    flag = "rage_random_hitpart",
    default = getgenv().Zero.Ragebot.RandomHitPart,
    callback = function(v)
        getgenv().Zero.Ragebot.RandomHitPart = v
    end
})

Rage:toggle({
    name = "Multigun",
    flag = "rage_multigun",
    default = getgenv().Zero.Ragebot.Multigun,
    callback = function(v)
        getgenv().Zero.Ragebot.Multigun = v
    end
})

Rage:toggle({
    name = "KO Check",
    flag = "rage_ko",
    default = getgenv().Zero.Ragebot.Checks.Ko,
    callback = function(v)
        getgenv().Zero.Ragebot.Checks.Ko = v
    end
})

Rage:toggle({
    name = "Wall Check",
    flag = "rage_wall",
    default = getgenv().Zero.Ragebot.Checks.Wall,
    callback = function(v)
        getgenv().Zero.Ragebot.Checks.Wall = v
    end
})

Rage:slider({
    name = "Health Limit",
    flag = "rage_hp_limit",
    min = 0,
    max = 5,
    default = getgenv().Zero.Ragebot.Checks.Health_limit,
    interval = 0.1,
    callback = function(v)
        getgenv().Zero.Ragebot.Checks.Health_limit = v
    end
})

Rage:toggle({
    name = "Notifications",
    flag = "rage_notif",
    default = getgenv().Zero.Ragebot.Others.NotificationsEnabled,
    callback = function(v)
        getgenv().Zero.Ragebot.Others.NotificationsEnabled = v
    end
})

Rage:toggle({
    name = "Tracer",
    flag = "rage_tracer",
    default = getgenv().Zero.Ragebot.Others.Tracer.Enabled,
    callback = function(v)
        getgenv().Zero.Ragebot.Others.Tracer.Enabled = v
    end
})
Rage:colorpicker({
    name = "Tracer Color",
    flag = "rage_tracer_color",
    color = getgenv().Zero.Ragebot.Others.Tracer.Color,
    callback = function(c)
        getgenv().Zero.Ragebot.Others.Tracer.Color = c
    end
})

Rage:toggle({
    name = "Hit Sound",
    flag = "rage_hitsound",
    default = getgenv().Zero.Ragebot.Others.HitSound,
    callback = function(v)
        getgenv().Zero.Ragebot.Others.HitSound = v
    end
})

Rage:dropdown({
    name = "Sound Type",
    flag = "rage_sound_type",
    items = {"neverlose", "coin", "pop", "error", "click", "snipe", "uwu", "retro", "sf"},
    default = getgenv().Zero.Ragebot.Others.Sound,
    multi = false,
    callback = function(v)
        getgenv().Zero.Ragebot.Others.Sound = v
    end
})

-- Silent Aim Section
local Silent = Main:section({ name = "Silent Aim", side = "right" })

Silent:toggle({
    name = "Enabled",
    flag = "silent_enabled",
    default = getgenv().Zero.Silent.Enabled,
    callback = function(v)
        getgenv().Zero.Silent.Enabled = v
    end
})

Silent:toggle({
    name = "Magic Bullet",
    flag = "silent_magic_bullet",
    default = getgenv().Zero.Silent.MagicBullet,
    callback = function(v)
        getgenv().Zero.Silent.MagicBullet = v
    end
})

Silent:toggle({
    name = "Show Fov",
    flag = "silent_show_fov",
    default = getgenv().Zero.Silent.FOV.ShowFOV,
    callback = function(v)
        getgenv().Zero.Silent.FOV.ShowFOV = v
    end
})

Silent:slider({
    name = "Fov Radius",
    flag = "silent_fov_radius",
    min = 50,
    max = 500,
    default = getgenv().Zero.Silent.FOV.Radius,
    interval = 1,
    callback = function(v)
        getgenv().Zero.Silent.FOV.Radius = v
    end
})

Silent:dropdown({
    name = "Hitpart",
    flag = "silent_hitpart",
    items = { "Head", "HumanoidRootPart", "UpperTorso" },
    default = getgenv().Zero.Silent.Hitpart,
    multi = false,
    callback = function(v)
        getgenv().Zero.Silent.Hitpart = v
    end
})

Silent:dropdown({
    name = "Air Hitpart",
    flag = "silent_air_hitpart",
    items = { "HumanoidRootPart", "LowerTorso" },
    default = getgenv().Zero.Silent.Airhitpart,
    multi = false,
    callback = function(v)
        getgenv().Zero.Silent.Airhitpart = v
    end
})

Silent:toggle({
    name = "Closest Hitpart",
    flag = "silent_closest",
    default = getgenv().Zero.Silent.Closesthitpart,
    callback = function(v)
        getgenv().Zero.Silent.Closesthitpart = v
    end
})

Silent:toggle({
    name = "KO Check",
    flag = "silent_ko",
    default = getgenv().Zero.Silent.Checks.Ko,
    callback = function(v)
        getgenv().Zero.Silent.Checks.Ko = v
    end
})

Silent:toggle({
    name = "Wall Check",
    flag = "silent_wall",
    default = getgenv().Zero.Silent.Checks.Wall,
    callback = function(v)
        getgenv().Zero.Silent.Checks.Wall = v
    end
})

Silent:slider({
    name = "Health Limit",
    flag = "silent_hp_limit",
    min = 0,
    max = 5,
    default = getgenv().Zero.Silent.Checks.Health_limit,
    interval = 0.1,
    callback = function(v)
        getgenv().Zero.Silent.Checks.Health_limit = v
    end
})

Silent:toggle({
    name = "Hit Sound",
    flag = "silent_hitsound",
    default = getgenv().Zero.Silent.HitSound,
    callback = function(v)
        getgenv().Zero.Silent.HitSound = v
    end
})

Silent:dropdown({
    name = "Sound Type",
    flag = "silent_sound_type",
    items = {"neverlose", "coin", "pop", "error", "click", "snipe", "uwu", "retro", "sf"},
    default = getgenv().Zero.Silent.Sound,
    multi = false,
    callback = function(v)
        getgenv().Zero.Silent.Sound = v
    end
})

-- Self Section
local Self = Localplayertab:section({ name = "Self", side = "left" })

Self:toggle({
    name = "CFrame Speed",
    flag = "cf_enabled",
    default = getgenv().Zero.Self.CFrameSpeed.Enabled,
    callback = function(v)
        getgenv().Zero.Self.CFrameSpeed.Enabled = v
    end
})
Self:keybind({
    name = "CFrame Keybind",
    flag = "cf_key",
    default = getgenv().Zero.Self.CFrameSpeed.Keybind,
    callback = function()
        getgenv().Zero.Self.CFrameSpeed.Keybind = flags["cf_key"].key
    end
})

Self:slider({
    name = "Speed",
    flag = "cf_speed",
    min = 1,
    max = 10,
    default = getgenv().Zero.Self.CFrameSpeed.Speed,
    interval = 1,
    callback = function(v)
        getgenv().Zero.Self.CFrameSpeed.Speed = v
    end
})

Self:toggle({
    name = "CFrame Fly",
    flag = "fly_enabled",
    default = getgenv().Zero.Self.CFrameFly.Enabled,
    callback = function(v)
        getgenv().Zero.Self.CFrameFly.Enabled = v
        if not v then
            flyActive = false
        end
    end
})

Self:keybind({
    name = "Fly Keybind",
    flag = "fly_key",
    default = getgenv().Zero.Self.CFrameFly.Keybind,
    callback = function()
        getgenv().Zero.Self.CFrameFly.Keybind = flags["fly_key"].key
    end
})

Self:slider({
    name = "Fly Speed",
    flag = "fly_speed",
    min = 1,
    max = 10,
    default = getgenv().Zero.Self.CFrameFly.Speed,
    interval = 1,
    callback = function(v)
        getgenv().Zero.Self.CFrameFly.Speed = v
    end
})

Self:toggle({
    name = "Void Hide",
    flag = "void_hide",
    default = getgenv().Zero.Self.Voidhide.Enabled,
    callback = function(v)
        getgenv().Zero.Self.Voidhide.Enabled = v
    end
})

Self:dropdown({
    name = "Void Mode",
    flag = "void_mode",
    items = {"Normal", "Spam"},
    default = getgenv().Zero.Self.Voidhide.VoidMode,
    multi = false,
    callback = function(v)
        getgenv().Zero.Self.Voidhide.VoidMode = v
    end
})

Self:keybind({
    name = "Void Keybind",
    flag = "void_hide_key",
    default = getgenv().Zero.Self.Voidhide.Keybind,
    callback = function()
        getgenv().Zero.Self.Voidhide.Keybind = flags["void_hide_key"].key
    end
})

Self:toggle({
    name = "Visualize Desync",
    flag = "visualize_desync",
    default = getgenv().Zero.Self.Voidhide.Visualize_Desync,
    callback = function(v)
        getgenv().Zero.Self.Voidhide.Visualize_Desync = v
        if desync then
            desync.LocalVisualESP = v
        end
    end
})

local Self2 = Localplayertab:section({ name = "Emotes", side = "right" })
local emotetoggle
Self2:toggle({
    name = "Animation enabled",
    flag = "emote_enabled",
    default = false,
    callback = function(v)
        emotetoggle = v 
        if not emotetoggle then
            AnimationLoader:Stop()
        else 
            AnimationLoader:Start()
        end
    end
})

Self2:dropdown({
    name = "Emotes",
    flag = "emote_list",
    items = {"floss", "sleep"},
    default = "floss",
    multi = false,
    callback = function(v)
        if v == "floss" then 
            AnimationLoader:SetEmote("floss")
        elseif v == "sleep" then
            AnimationLoader:SetEmote("sleep")
        end
    end
})

-- Follow Target Section
local Follow = Main:section({ name = "Follow Target", side = "left" })

Follow:toggle({
    name = "Enabled",
    flag = "follow_enabled",
    default = getgenv().Zero.Ragebot.FollowTarget.Enabled,
    callback = function(v)
        getgenv().Zero.Ragebot.FollowTarget.Enabled = v
    end
})

Follow:slider({
    name = "Radius",
    flag = "follow_radius",
    min = 5,
    max = 25,
    default = getgenv().Zero.Ragebot.FollowTarget.Radius,
    interval = 1,
    callback = function(v)
        getgenv().Zero.Ragebot.FollowTarget.Radius = v
    end
})

Follow:toggle({
    name = "Spectate",
    flag = "follow_spectate",
    default = getgenv().Zero.Ragebot.FollowTarget.Spectate,
    callback = function(v)
        getgenv().Zero.Ragebot.FollowTarget.Spectate = v
    end
})

-- ========== OTHERS TAB ==========


local OtherSec = Main:section({ name = "Other", side = "right" })

OtherSec:toggle({
    name = "Auto Stomp",
    flag = "auto_stomp",
    default = getgenv().Zero.Otherslol.Autostomp,
    callback = function(v)
        getgenv().Zero.Otherslol.Autostomp = v
    end
})

OtherSec:toggle({
    name = "Auto Reload",
    flag = "auto_reload",
    default = getgenv().Zero.Otherslol.Autoreload,
    callback = function(v)
        getgenv().Zero.Otherslol.Autoreload = v
    end
})

OtherSec:toggle({
    name = "Rapid Fire",
    flag = "rapid_fire",
    default = getgenv().Zero.Otherslol.Rapidfire,
    callback = function(v)
        getgenv().Zero.Otherslol.Rapidfire = v
    end
})

OtherSec:keybind({
    name = "Get Armor",
    flag = "armor_key",
    default = getgenv().Zero.Otherslol.Armorkeybind,
    callback = function()
        getgenv().Zero.Otherslol.Armorkeybind = flags["armor_key"].key
    end
})

-- local resolvesec = Main:section({ name = "Resolver", side = "left" })

-- resolvesec:toggle({
--     name = "Resolver",
--     flag = "resolver_enabled",
--     default = getgenv().Zero.Resolver.Enabled,
--     callback = function(v)
--         getgenv().Zero.Resolver.Enabled = v
--     end
-- })

-- resolvesec:dropdown({
--     name = "Resolver Method",
--     flag = "resolver_method",
--     items = {"MoveDirection", "Velocity", "Recalculate"},
--     default = getgenv().Zero.Resolver.Method,
--     multi = false,
--     callback = function(v)
--         getgenv().Zero.Resolver.Method = v
--     end
-- })

-- resolvesec:slider({
--     name = "Confidence",
--     flag = "resolver_confidence",
--     min = 0.1,
--     max = 0.3,
--     default = getgenv().Zero.Resolver.Confidence,
--     interval = 0.001,
--     callback = function(v)
--         getgenv().Zero.Resolver.Confidence = v
--     end
-- })

-- resolvesec:slider({
--     name = "Sensitivity",
--     flag = "resolver_sensitivity",
--     min = 500,
--     max = 2000,
--     default = getgenv().Zero.Resolver.Sensitivity,
--     interval = 50,
--     callback = function(v)
--         getgenv().Zero.Resolver.Sensitivity = v
--     end
-- })

local misctab = Main:section({ name = "misc", side = "left" })
local RunService = game:GetService("RunService")
local lp = game.Players.LocalPlayer

local attachWeld = nil
local conn = nil
local offsetDistance = -1 

misctab:toggle({
    name = "Connection exploit",
    flag = "connection_exploit",
    default = getgenv().Zero.Ragebot.ConnectionExploit,
    callback = function(v)
        getgenv().Zero.Ragebot.ConnectionExploit = v

        if v then
            conn = RunService.Stepped:Connect(function()
                if not (LockedOn and CurrentTarget and CurrentTarget.Character and lp.Character) then 
                    return
                end

                local myChar = lp.Character
                local targetChar = CurrentTarget.Character

                local myRoot = myChar:FindFirstChild("HumanoidRootPart")
                local targetRoot = targetChar:FindFirstChild("LowerTorso") 
                    or targetChar:FindFirstChild("HumanoidRootPart")
                    or targetChar:FindFirstChild("Torso") -- R6 fallback

                if not (myRoot and targetRoot) then return end

                -- Calculate position behind target (offsetDistance is already -1)
                local behindCFrame = targetRoot.CFrame * CFrame.new(0, 0, offsetDistance)

                -- Direct CFrame teleport
                myRoot.CFrame = behindCFrame

                -- Also spam weld for extra attachment
                local tempWeld = Instance.new("Weld")
                tempWeld.Part0 = myRoot
                tempWeld.Part1 = targetRoot
                tempWeld.C0 = CFrame.new(0, 0, offsetDistance)
                tempWeld.Parent = myRoot
                
                -- Destroy immediately
                tempWeld:Destroy()

                -- knife logic
                local knife = myChar:FindFirstChild("[Knife]") 
                    or lp.Backpack:FindFirstChild("[Knife]")

                if knife then
                    knife.Parent = myChar
                    knife:Activate()
                end
            end)
        else
            if conn then
                conn:Disconnect()
                conn = nil
            end
        end
    end
})

misctab:toggle({
    name = "God mode",
    flag = "god_mode",
    default = false,
    callback = function(v)
        if HoodcustomsId[game.PlaceId] then
			togglegod(v)
		else
			library:notification({ text = "Hood customs only feature." }, 5)
		end
	end
})



local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local connnig
misctab:toggle({
    name = "Anti flame",
    flag = "Anti_flame",
    default = false,
    callback = function(v)
        getgenv().Zero.Otherslol.Antiflame = v
        
        if v then 
            local character = game.Players.LocalPlayer.Character
            if not character then return end
            
            local thing = character:FindFirstChild("HumanoidRootPart")
            if not thing then return end
            
            -- Save current position
            local savedCFrame = thing.CFrame
            
            game.Workspace.FallenPartsDestroyHeight = 0/0
            
            connnig = game:GetService("RunService").Heartbeat:Connect(function()
                if thing then
                    thing.CFrame = CFrame.new(
                        thing.Position.X + math.random(-15e10, 15e10),
                        thing.Position.Y + math.random(-15e10, 15e10),
                        thing.Position.Z + math.random(-15e10, 15e10)
                    )
                end
            end)
            
            -- Store saved position for later
            getgenv().savedAntiFlamePos = savedCFrame
        else
            if connnig then
                connnig:Disconnect()
                connnig = nil
                
                -- Teleport back to saved position
                local character = game.Players.LocalPlayer.Character
                if character and getgenv().savedAntiFlamePos then
                    local thing = character:FindFirstChild("HumanoidRootPart")
                    if thing then
                        thing.CFrame = getgenv().savedAntiFlamePos
                    end
                end
                
                getgenv().savedAntiFlamePos = nil
            end
        end
    end
})

local KASEC = Main:section({ name = "Kill Aura Settings", side = "right" })

KASEC:toggle({
    name = "Enabled",
    flag = "kill_aura_enabled",
    default = false,
    callback = function(v)
       getgenv().Zero.Ragebot.Kill_Aura.Enabled = v
	   end
})

KASEC:dropdown({
    name = "Mode",
    flag = "ka_mode",
    items = { "Normal", "Aug"},
    default = getgenv().Zero.Ragebot.Kill_Aura.Mode,
    multi = false,
    callback = function(v)
        getgenv().Zero.Ragebot.Kill_Aura.Mode = v
    end
})

KASEC:slider({
    name = "Radius",
    flag = "rage_ka_radius",
    min = 1,
    max = 50,
    default = getgenv().Zero.Ragebot.Kill_Aura.Radius,
    interval = 1,
    callback = function(v)
        getgenv().Zero.Ragebot.Kill_Aura.Radius = v
    end
})

if DahoodId[game.PlaceId] then 
    local Dahood = window:tab({ name = "Da Hood" })
   local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local cashierFolder = workspace:FindFirstChild("Cashiers")
local dropFolder = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Drop")

local attackRadius = 15
local atmfarm = false
local noclipConnection = nil

local TIMEOUT_SECONDS = 10      -- how long to wait before skipping a stuck ATM
local ATTACK_INTERVAL = 0.001     -- how often to attack / check

local function equipCombat()
    local character = LocalPlayer.Character
    if not character then return end
    
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then return end
    
    local tool = character:FindFirstChild("Combat") or backpack:FindFirstChild("Combat")
    if tool and not character:FindFirstChild("Combat") then
        character.Humanoid:EquipTool(tool)
    end
end

local function setNoClip(enabled)
    if enabled then
        if noclipConnection then return end
        noclipConnection = RunService.Stepped:Connect(function()
            local character = LocalPlayer.Character
            if character then
                for _, part in character:GetChildren() do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
    end
end

local function teleportTo(position)
    local character = LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        character.HumanoidRootPart.CFrame = CFrame.new(position + Vector3.new(0, 3, 0)) -- slight height helps
    end
end

local function collectDrops()
    if not dropFolder then return end
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    for _, drop in dropFolder:GetChildren() do
        if drop:IsA("BasePart") then
            local dist = (drop.Position - hrp.Position).Magnitude
            if dist <= attackRadius then
                local clickDetector = drop:FindFirstChildWhichIsA("ClickDetector", true)
                if clickDetector then
                    fireclickdetector(clickDetector)
                end
            end
        end
    end
end

local function farmLoop()
    setNoClip(true)
    
    while atmfarm do
        if not cashierFolder then
            task.wait(1)
            continue
        end
        
        local cashiers = cashierFolder:GetChildren()
        for _, cashier in cashiers do
            if not atmfarm then break end
            if cashier.Name ~= "CA$HIER" then continue end
            
            local humanoid = cashier:FindFirstChildWhichIsA("Humanoid", true)
            if not humanoid or humanoid.Health <= 0 then continue end
            
            local rootPart = cashier.PrimaryPart or cashier:FindFirstChildWhichIsA("BasePart", true)
            if not rootPart then continue end
            
            equipCombat()
            
            local startHealth = humanoid.Health
            local startTime = tick()
            local timedOut = false
            
            -- Attack this cashier until dead or timeout
            while atmfarm and humanoid.Health > 0 and not timedOut do
                teleportTo(rootPart.Position)
                
                local character = LocalPlayer.Character
                local combat = character and character:FindFirstChild("Combat")
                
                if combat then
                    combat:Activate()
                else
                    equipCombat()
                end
                
                collectDrops()
                
                -- Check for timeout (stuck / no damage)
                if tick() - startTime >= TIMEOUT_SECONDS then
                    if humanoid.Health >= startHealth then
                        -- No damage taken → probably stuck / bugged
                        timedOut = true
                        -- Optional: print("Timed out on cashier - skipping")
                    else
                        -- Got some damage → reset timer and keep going
                        startHealth = humanoid.Health
                        startTime = tick()
                    end
                end
                
                task.wait(ATTACK_INTERVAL)
            end
            
            -- After kill or timeout → collect drops aggressively for a moment
            if atmfarm then
                for i = 1, 12 do
                    if not atmfarm then break end
                    collectDrops()
                    task.wait(0.2)
                end
            end
            
            task.wait(0.15) -- small delay between cashiers
        end
        
        task.wait(0.3) -- delay before restarting the whole list
    end
    
    setNoClip(false)
end

    local dhsec = Dahood:section({ name = "Misc", side = "left" })
dhsec:toggle({
    name = "ATM farm",
    flag = "atm_farm",
    default = false,
    callback = function(v)
       atmfarm = v  

if atmfarm then
    task.spawn(farmLoop)
end
	   end
})


end

if HoodcustomsId[game.PlaceId] then 
    local HoodCustoms = window:tab({ name = "Hood customs" })
    local Hoodcsec = HoodCustoms:section({ name = "Misc", side = "left" })
Hoodcsec:toggle({
    name = "-",
    flag = "-",
    default = false,
    callback = function(v)
       
	   end
})
end


-- ========== VISUALS TAB ==========


local VisSec1 = Visuals:section({ name = "ESP", side = "left" })
local VisSec2 = Visuals:section({ name = "Other ESP", side = "left" })
local SelfVisSec = Visuals:section({ name = "Self Visuals", side = "left" })

VisSec1:toggle({
    name = "Box ESP",
    flag = "box_esp",
    default = false,
    callback = function(v)
        getgenv().Zero.BoxESP.Enabled = v
    end
})

VisSec1:dropdown({
    name = "Box Type",
    flag = "box_type",
    items = { "Normal", "Corner"},
    default = "Normal",
    multi = false,
    callback = function(v)
        if v == "Normal" then 
            getgenv().Zero.BoxESP.Type = "Full"
        elseif v == "Corner" then
            getgenv().Zero.BoxESP.Type = "Corner"
        end
    end
})
VisSec1:colorpicker({
    name = "Box Color",
    flag = "rage_box_color",
    color = getgenv().Zero.BoxESP.Color,
    callback = function(c)
        getgenv().Zero.BoxESP.Color = c
    end
})

VisSec1:toggle({
    name = "Name ESP",
    flag = "name_esp",
    default = false,
    callback = function(v)
        if toggleESP then
            toggleESP("Name", v)
        end
    end
})

VisSec1:toggle({
    name = "Distance ESP",
    flag = "distance_esp",
    default = false,
    callback = function(v)
        if toggleESP then
            toggleESP("Distance", v)
        end
    end
})

VisSec1:toggle({
    name = "Weapon ESP",
    flag = "weapon_esp",
    default = false,
    callback = function(v)
        if toggleESP then
            toggleESP("Weapon", v)
        end
    end
})

VisSec2:toggle({
    name = "Highlight Enabled",
    flag = "chams_enabled",
    default = getgenv().Zero.Chams.Enabled,
    callback = function(v)
        getgenv().Zero.Chams.Enabled = v
        if updateChams then
            updateChams()
        end
    end
})

VisSec2:colorpicker({
    name = "Fill Color",
    flag = "chams_fill_color",
    color = getgenv().Zero.Chams.FillColor,
    alpha = getgenv().Zero.Chams.FillTransparency,
    callback = function(color, alpha)
        getgenv().Zero.Chams.FillColor = color
        getgenv().Zero.Chams.FillTransparency = alpha
        if updateChams then
            updateChams()
        end
    end
})

VisSec2:colorpicker({
    name = "Outline Color",
    flag = "chams_outline_color",
    color = getgenv().Zero.Chams.OutlineColor,
    alpha = getgenv().Zero.Chams.OutlineTransparency,
    callback = function(color, alpha)
        getgenv().Zero.Chams.OutlineColor = color
        getgenv().Zero.Chams.OutlineTransparency = alpha
        if updateChams then
            updateChams()
        end
    end
})


SelfVisSec:toggle({
    name = "Forcefield material",
    flag = "self_forcefield_enabled",
    default = ff_enabled,
    callback = function(v)
        ff_enabled = v
        if player.Character then
            applyForcefield(player.Character, v)
        end
    end
})

SelfVisSec:colorpicker({
    name = "Forcefield color",
    flag = "ff_color",
    color = ff_color,
    callback = function(newColor)
        ff_color = newColor
        if ff_enabled and player.Character then
            applyForcefield(player.Character, false)   -- clear first
            applyForcefield(player.Character, true)    -- re-apply with new color
        end
    end
})

SelfVisSec:slider({
    name = "Transparency",
    flag = "ff_transparency",
    min = 0.1,
    max = 0.9,
    default = ff_transparency,
    interval = 0.05,
    callback = function(value)
        ff_transparency = value
        if ff_enabled and player.Character then
            applyForcefield(player.Character, false)
            applyForcefield(player.Character, true)
        end
    end
})

local aura_enabled

SelfVisSec:toggle({
    name = "Particle Aura",
    flag = "particle_aura",
    default = false,
    callback = function(v)
        aura_enabled = v
        ParticleAura.toggle(v)
    end
})

SelfVisSec:dropdown({
    name = "Aura Type",
    flag = "aura_type",
    items = ParticleAura.types,
    default = "angel",
    multi = false,
    callback = function(v)
        ParticleAura.setType(v)
    end
})

SelfVisSec:colorpicker({
    name = "Aura Color",
    flag = "aura_color",
    color = Color3.fromRGB(133, 220, 255),
    callback = function(c)
        ParticleAura.setColor(c)
    end
})



local worldvistab = Visuals:section({ name = "World visuals", side = "right" })

worldvistab:toggle({
    name = "World enabled",
    flag = "world_enabled",
    default = false,
    callback = function(v)
        if v then
            worldVis:Start()
        else
            worldVis:Reset()
        end
    end
})

-- World Time
worldvistab:toggle({
    name = "World Time",
    flag = "world_time_enabled",
    default = false,
    callback = function(v)
        worldVis:SetConfig("world_time", { enabled = v })
    end
})

worldvistab:slider({
    name = "Time",
    flag = "world_time_hour",
    min = 0,
    max = 24,
    default = 6.5,
    interval = 0.5,
    callback = function(v)
        worldVis:SetConfig("world_time", { hour = v })
    end
})

-- Atmosphere
worldvistab:toggle({
    name = "Atmosphere",
    flag = "atmosphere_enabled",
    default = false,
    callback = function(v)
        worldVis:SetConfig("atmosphere", { enabled = v })
    end
})

worldvistab:colorpicker({
    name = "Atmosphere Color",
    flag = "atmosphere_color",
    color = Color3.fromRGB(255,192,203),
    callback = function(c)
        worldVis:SetConfig("atmosphere", { color = c })
    end
})

-- Ambient Lighting
worldvistab:toggle({
    name = "Ambient Lighting",
    flag = "ambient_enabled",
    default = false,
    callback = function(v)
        worldVis:SetConfig("ambient", { enabled = v })
    end
})

worldvistab:colorpicker({
    name = "Indoor Color",
    flag = "ambient_indoor",
    color = Color3.fromRGB(255,192,203),
    callback = function(c)
        worldVis:SetConfig("ambient", { indoor_color = c })
    end
})

worldvistab:colorpicker({
    name = "Outdoor Color",
    flag = "ambient_outdoor",
    color = Color3.fromRGB(255,192,203),
    callback = function(c)
        worldVis:SetConfig("ambient", { outdoor_color = c })
    end
})

-- Weather
-- Weather Toggle
worldvistab:toggle({
    name = "Weather",
    flag = "weather_enabled",
    default = false,
    callback = function(v)
        worldVis.config.weather.enabled = v
        -- Full recreate for toggle
        worldVis:UpdateWeather()
    end
})

-- Weather Type Dropdown - ONLY recreate particle, not everything
worldvistab:dropdown({
    name = "Weather Type",
    flag = "weather_type",
    items = {"rain", "snow", "light rain"},
    default = "rain",
    multi = false,
    callback = function(v)
        worldVis.config.weather.type = v
        
        -- Only update if weather is already enabled
        if worldVis.weather_particle and worldVis.config.weather.enabled then
            worldVis.weather_particle:Destroy()
            
            local data = worldVis.weather_types[v]
            if data then
                local weather_data = {}
                for k, val in pairs(data) do
                    weather_data[k] = val
                end
                weather_data.Rate = data.Rate * (worldVis.config.weather.rate / 100)
                
                worldVis.weather_particle = Instance.new("ParticleEmitter")
                for prop, value in pairs(weather_data) do
                    worldVis.weather_particle[prop] = value
                end
                worldVis.weather_particle.Color = ColorSequence.new(worldVis.config.weather.color)
                worldVis.weather_particle.Enabled = true
                worldVis.weather_particle.Parent = worldVis.weather_part
            end
        end
    end
})

-- Weather Color - ONLY update color
worldvistab:colorpicker({
    name = "Weather Color",
    flag = "weather_color",
    color = Color3.fromRGB(255, 255, 255),
    callback = function(c)
        worldVis.config.weather.color = c
        
        -- Only update if weather exists
        if worldVis.weather_particle then
            worldVis.weather_particle.Color = ColorSequence.new(c)
        end
    end
})

-- Weather Rate - ONLY update rate
worldvistab:slider({
    name = "Weather Rate",
    flag = "weather_rate",
    min = 1,
    max = 100,
    default = 100,
    interval = 1,
    callback = function(v)
        worldVis.config.weather.rate = v
        
        -- Only update if weather exists
        if worldVis.weather_particle then
            local data = worldVis.weather_types[worldVis.config.weather.type]
            if data then
                worldVis.weather_particle.Rate = data.Rate * (v / 100)
            end
        end
    end
})

-- Skybox
worldvistab:toggle({
    name = "Skybox",
    flag = "skybox_enabled",
    default = false,
    callback = function(v)
        worldVis:SetConfig("skybox", { enabled = v })
    end
})

worldvistab:dropdown({
    name = "Skybox Preset",
    flag = "skybox_preset",
    items = {"black storm", "blue space", "realistic", "stormy", "pink"},
    default = "black storm",
    multi = false,
    callback = function(v)
        worldVis:SetConfig("skybox", { preset = v })
    end
})

-- Textures
worldvistab:toggle({
    name = "Textures",
    flag = "textures_enabled",
    default = false,
    callback = function(v)
        worldVis:SetConfig("textures", { enabled = v })
    end
})

worldvistab:dropdown({
    name = "Texture Pack",
    flag = "texture_pack",
    items = {"minecraft"},
    default = "minecraft",
    multi = false,
    callback = function(v)
        worldVis:SetConfig("textures", { pack = v })
    end
})

-- ========== CONFIGS TAB ==========

local config_section = Configs:section({ name = "Configuration System", side = "left" })

local dir = "zeroconfigs/"

-- Create directory if it doesn't exist
pcall(function()
    if not isfolder(dir) then
        makefolder(dir)
    end
end)

-- Function to get all config files
local function getConfigs()
    local configs = {}
    pcall(function()
        local files = listfiles(dir)
        for _, file in ipairs(files) do
            local name = string.match(file, dir .. "(.+)%.cfg")
            if name then
                table.insert(configs, name)
            end
        end
    end)
    return configs
end

-- Store references to avoid obfuscation issues
local config_name_list_flag = "config_name_list"
local config_name_text_flag = "config_name_text_box"

-- Populate dropdown
library.config_holder = config_section:dropdown({
    name = "Configs",
    items = getConfigs(),
    flag = config_name_list_flag,
    multi = false
})

-- Textbox for new config name
config_section:textbox({
    flag = config_name_text_flag
})

-- Helper functions to avoid inline concatenation
local function getConfigPath(name)
    return dir .. tostring(name) .. ".cfg"
end

local function getConfigName(flagName)
    return flags[flagName]
end

-- Create button
config_section:button({
    name = "Create",
    callback = function()
        pcall(function()
            local name = getConfigName(config_name_text_flag)
            if name and name ~= "" then
                local path = getConfigPath(name)
                local configData = library:get_config()
                writefile(path, configData)
                library:notification({ text = "Config created: " .. tostring(name) }, 5)
                
                -- Refresh dropdown
                library.config_holder:update_list(getConfigs())
            end
        end)
    end
})

-- Delete button
config_section:button({
    name = "Delete",
    callback = function()
        pcall(function()
            local name = getConfigName(config_name_list_flag)
            if name then
                library:panel({
                    name = "Are you sure you want to delete " .. tostring(name) .. "?",
                    options = { "Yes", "No" },
                    callback = function(option)
                        if option == "Yes" then
                            pcall(function()
                                local path = getConfigPath(name)
                                delfile(path)
                                library:notification({ text = "Config deleted: " .. tostring(name)}, 5)
                                
                                -- Refresh dropdown
                                library.config_holder:update_list(getConfigs())
                            end)
                        end
                    end
                })
            end
        end)
    end
})

-- Load button
config_section:button({
    name = "Load",
    callback = function()
        pcall(function()
            local name = getConfigName(config_name_list_flag)
            if name then
                local path = getConfigPath(name)
                local configData = readfile(path)
                library:load_config(configData)
                library:notification({ text = "Config loaded: " .. tostring(name)}, 5)
            end
        end)
    end
})

-- Save button
config_section:button({
    name = "Save",
    callback = function()
        pcall(function()
            local name = getConfigName(config_name_list_flag)
            if name then
                local path = getConfigPath(name)
                local configData = library:get_config()
                writefile(path, configData)
                library:notification({ text = "Config saved: " .. tostring(name) }, 5)
            end
        end)
    end
})

-- Unload button
config_section:button({
    name = "Unload Config",
    callback = function()
        pcall(function()
            if library.old_config then
                library:load_config(library.old_config)
                library:notification({ text = "Config unloaded" }, 5)
            end
        end)
    end
})

config_section:button({
    name = "Unload Menu",
    callback = function()
        pcall(function()
            library:unload()
        end)
    end
})



task.wait()
pcall(function()
    library.old_config = library:get_config()
end)



local config_nigga = Configs:section({ name = "Menu", side = "right" })
config_nigga:keybind({name = "UI Bind", default = Enum.KeyCode.LeftAlt,
 callback = function(v)
  window.set_menu_visibility(v)
  
 end})
-- remove fuckahh watermark and playerlist
window.toggle_watermark(false)
window.toggle_playerlist(false)
-- change color
library:update_theme("accent", Color3.fromRGB(255,111,255))

local req = (http_request or request or syn.request)

    local universeId = game.GameId
    local res = req({
    Url = "https://games.roblox.com/v1/games?universeIds=" .. universeId,
    Method = "GET"
    })

    local data = game:GetService("HttpService"):JSONDecode(res.Body)
    local gamename = data.data[1].name

for i = 1, 15 do 
    if HoodcustomsId[game.PlaceId] then 
		library:notification({text = "Hood customs detected, force hit is automatically enabled when auto fire is"}, 10)
	elseif 
	DahoodId[game.PlaceId] then 
		library:notification({text = "Da hood detected, force hit is automatically enabled when auto fire is"}, 10)
	else 
		library:notification({text = gamename.." Detected."}, 5)
	end 
end

Main.open_tab()
end)
